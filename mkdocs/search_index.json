{
    "docs": [
        {
            "location": "/", 
            "text": "Scala Debugger API\n\n\nScala abstractions and tooling around the Java Debugger Interface.\n\n\nval fileName = \nfile.scala\n\nval lineNumber = 37\n\nscalaVirtualMachine.onUnsafeBreakpoint(fileName, lineNumber).foreach(breakpointEvent =\n {\n    println(s\nReached breakpoint $fileName:$lineNumber\n)\n})\n\n\n\n\n\n\n Installation\n\n\nWhen using sbt:\n\n\nlibraryDependencies += \norg.scala-debugger\n %% \nscala-debugger-api\n % \n1.0.0\n\n\n\n\n\nTo be able to compile code using the Java Debugger Interface, you need to also\nadd this plugin to your \nproject/plugins.sbt\n file:\n\n\naddSbtPlugin(\norg.scala-debugger\n % \nsbt-jdi-tools\n % \n1.0.0\n)\n\n\n\n\nSee the \ninstallation page\n for more information.\n\n\n\n\n Documentation\n\n\n\n    \n\n        \n\n            \n\n            \nGetting Started\n\n            \nQuick introduction to debugging and using the Scala debugger API.\n\n        \n\n    \n\n\n    \n\n        \n\n            \n\n            \nAdvanced Topics\n\n            \nExplanations of more advanced Scala debugger API features.\n\n        \n\n    \n\n\n\n\n\n\n    \n\n        \n\n            \n\n            \nCookbook\n\n            \nBrief code examples for common cases when using the Scala debugger API.\n\n        \n\n    \n\n\n    \n\n        \n\n            \n\n            \nScaladoc\n\n            \nReference material for all programmatic APIs in the Scala debugger API.\n\n        \n\n    \n\n\n\n\n\n\n\n Contributing\n\n\nAll contributions are welcome! As a reminder, the project is licensed under the\n\nApache 2.0 license\n.\n\n\n\n    \n\n        \n\n            \n\n            \nRoadmap\n\n            \nView the planned features here.\n\n        \n\n    \n\n\n    \n\n        \n\n            \n\n            \n\n            \nIssues\n\n            \nReport bugs and request features here.\n\n        \n\n    \n\n\n    \n\n        \n\n            \n\n            \nPull Requests\n\n            \nSubmit your own fixes and features here.\n\n        \n\n    \n\n\n\n\n\n\n\nSee the \ncontributing\n page for more information.\n\n\n\n\n\n    \nSite main page inspired by content from \nScalaMock\n.\n\n    \nProject proudly a member of \nENSIME\n.", 
            "title": "Home"
        }, 
        {
            "location": "/#scala-debugger-api", 
            "text": "Scala abstractions and tooling around the Java Debugger Interface.  val fileName =  file.scala \nval lineNumber = 37\n\nscalaVirtualMachine.onUnsafeBreakpoint(fileName, lineNumber).foreach(breakpointEvent =  {\n    println(s Reached breakpoint $fileName:$lineNumber )\n})", 
            "title": "Scala Debugger API"
        }, 
        {
            "location": "/#installation", 
            "text": "When using sbt:  libraryDependencies +=  org.scala-debugger  %%  scala-debugger-api  %  1.0.0   To be able to compile code using the Java Debugger Interface, you need to also\nadd this plugin to your  project/plugins.sbt  file:  addSbtPlugin( org.scala-debugger  %  sbt-jdi-tools  %  1.0.0 )  See the  installation page  for more information.", 
            "title": " Installation"
        }, 
        {
            "location": "/#documentation", 
            "text": "Getting Started \n             Quick introduction to debugging and using the Scala debugger API. \n         \n     \n\n     \n         \n             \n             Advanced Topics \n             Explanations of more advanced Scala debugger API features. \n         \n       \n     \n         \n             \n             Cookbook \n             Brief code examples for common cases when using the Scala debugger API. \n         \n     \n\n     \n         \n             \n             Scaladoc \n             Reference material for all programmatic APIs in the Scala debugger API.", 
            "title": " Documentation"
        }, 
        {
            "location": "/#contributing", 
            "text": "All contributions are welcome! As a reminder, the project is licensed under the Apache 2.0 license .  \n     \n         \n             \n             Roadmap \n             View the planned features here. \n         \n     \n\n     \n         \n             \n             \n             Issues \n             Report bugs and request features here. \n         \n     \n\n     \n         \n             \n             Pull Requests \n             Submit your own fixes and features here. \n         \n        See the  contributing  page for more information.   \n     Site main page inspired by content from  ScalaMock . \n     Project proudly a member of  ENSIME .", 
            "title": " Contributing"
        }, 
        {
            "location": "/getting-started/what-is-a-debugger/", 
            "text": "What is a debugger?\n\n\nIn this section, you will get a brief overview of what a debugger is and the\nfeatures that it typically offers. You will also learn how the Scala debugger\nAPI is related to the Eclipse debugger (described below).\n\n\n\n\nOverview\n\n\nIn a nutshell, a debugger is a program written to aid in testing and debugging\nanother computer program. For those unfamiliar, debugging is the process of\nfinding and removing defects (bugs) in a computer program and can be\naccomplished in a variety of ways including examining log files for oddities,\nmonitoring the memory of an application or system, profiling for performance\nbottlenecks, utilizing test code to discover inconsistencies, and using\ninteractive debugging to examine the running state of your program.\n\n\nDebuggers come in quite a few different packages and, most likely, you have\nencountered at least one. Several more well-known debuggers include \nGDB\n,\ncommonly used to interactively debug C and C++ programs from the command line,\nand the \nEclipse Debug Project\n, which is part of the Eclipse IDE and\navailable for a variety of languages although most-specifically targeted\ntowards Java. If you have done any web-based frontend development, you have\nprobably used your browser's debugger such as\n\nGoogle Chrome's DevTools\n or \nMozilla Firefox's Debugger\n.\n\n\nWhile debuggers themselves are an old concept, the latest debuggers are\ncontinuing to demonstrate new, clever ideas to make the everyday programmer's\nlife a little easier. If interested in modern developments in the debugger\nspace, check out Elm's \ntime traveling debugger\n or Scala IDE's new\n\nasync debugger\n.\n\n\nFeatures\n\n\nA debugger can offer a wide range of features to aid the programmer in\ndiscovering and fixing defects. The most common features found in modern\ndebuggers are the ability to step through a program, stop (break) a program to\nexamine its state, and track the values of variables in a program.\n\n\nRunning a program step-by-step\n\n\nThis involves running a target program one \"line\" at a time, breaking at each\nnext \"line\" to observe the state of the program such as the values of variables\nin the stack frame. While line-by-line stepping is one of the most common and\nuseful forms of stepping through your program, some debuggers offer other step\nincrements such as frame-by-frame.\n\n\nNewer debuggers like Scala IDE's \nasync debugger\n offer the ability\nto step through your program even when the code execution path is not\nstraightforward (in this case when running distributed, message-driven programs\nusing the \nAkka toolkit and runtime\n).\n\n\nBreaking a program to examine its state\n\n\nThis involves setting what is known as a breakpoint, a marker in a program\nindicating that you want to stop execution temporarily, to be able to examine\nthe running state of a program. Often, breakpoints are placed on specific\nsource lines of a program indicating that the developer wishes to stop the\nprogram when executing a specific line to examine the current state. Earlier\nbreakpoints would be placed on specific instructions (assembly).\n\n\nOther forms of breakpoints can also exist including setting a conditional\nbreakpoint that triggers when reading/writing memory (watchpoints) or the\nevaluation of an expression yields true.\n\n\nWatching variables in a program\n\n\nWhen debugging a program, a common scenario is that a developer wants to\nknow when a variable's value is accessed or changed. This typically involves\nthe temporary suspension of the program allowing the developer to inspect the\ncurrent stack frame to understand what led to the access/modification of the\nvariable. Furthermore, more restrictions might be placed on the modification\nof a variable such that a developer is only notified when a variable is changed\nto a certain value, allowing more accurate understanding of specific problems\nsuch as when a variable unexpectedly becomes \nnull\n.\n\n\nEvaluating expressions\n\n\nA useful feature in many debuggers is the ability to evaluate an expression\n(snippet of code) in the target program while it is suspended due to a\nbreakpoint. This allows developers to quickly test functions and perform\nmodifications to the state of the program using the same language as the\nprogram itself.\n\n\nMore about Eclipse and how it relates to this project\n\n\nThe \nEclipse Debug Project\n offers two subprojects for debugging with\nthe Eclipse tooling: platform debug and JDT debug. Platform debug focuses on\ndefining language-independent debugging capabilities including defining\nbreakpoints (see features for more info), launching programs, and\nnotification of events from target programs. JDT debug is more specific as it\nimplements the Java debugging support to launch or attach to a JVM, evaluate\nexpressions in the context of a stack frame, and dynamically reload classes\ninto the target JVM.\n\n\nThe underlying API driving Eclipse's debugging framework for Java (and other\nJVM-based languages) is the \nJava Platform Debugger Architecture\n (JPDA).\nThe JDPA is a collection of APIs to debug Java code and includes the Java Debug\nWire Protocol (JDWP) defining communication between the debugger and target\nJVMs, the Java Virtual Machine Tools Interface (JVMTI) providing a native\ninterface (C++) to inspect state and control execution of programs running in\na JVM, and the \nJava Debugger Interface\n (\nJDI\n) that defines a high-level\nAPI in Java to debug remote JVMs.\n\n\nThe Scala debugger API is built on top of the \nJDI\n, wrapping existing \nJDI\n\nfunctionality in Scala-friendly wrappers and providing higher-level\nabstractions to aid Scala developers in writing debugger tooling and utilize\ndebugger functionality in their own applications.", 
            "title": "What is a Debugger?"
        }, 
        {
            "location": "/getting-started/what-is-a-debugger/#what-is-a-debugger", 
            "text": "In this section, you will get a brief overview of what a debugger is and the\nfeatures that it typically offers. You will also learn how the Scala debugger\nAPI is related to the Eclipse debugger (described below).", 
            "title": "What is a debugger?"
        }, 
        {
            "location": "/getting-started/what-is-a-debugger/#overview", 
            "text": "In a nutshell, a debugger is a program written to aid in testing and debugging\nanother computer program. For those unfamiliar, debugging is the process of\nfinding and removing defects (bugs) in a computer program and can be\naccomplished in a variety of ways including examining log files for oddities,\nmonitoring the memory of an application or system, profiling for performance\nbottlenecks, utilizing test code to discover inconsistencies, and using\ninteractive debugging to examine the running state of your program.  Debuggers come in quite a few different packages and, most likely, you have\nencountered at least one. Several more well-known debuggers include  GDB ,\ncommonly used to interactively debug C and C++ programs from the command line,\nand the  Eclipse Debug Project , which is part of the Eclipse IDE and\navailable for a variety of languages although most-specifically targeted\ntowards Java. If you have done any web-based frontend development, you have\nprobably used your browser's debugger such as Google Chrome's DevTools  or  Mozilla Firefox's Debugger .  While debuggers themselves are an old concept, the latest debuggers are\ncontinuing to demonstrate new, clever ideas to make the everyday programmer's\nlife a little easier. If interested in modern developments in the debugger\nspace, check out Elm's  time traveling debugger  or Scala IDE's new async debugger .", 
            "title": "Overview"
        }, 
        {
            "location": "/getting-started/what-is-a-debugger/#features", 
            "text": "A debugger can offer a wide range of features to aid the programmer in\ndiscovering and fixing defects. The most common features found in modern\ndebuggers are the ability to step through a program, stop (break) a program to\nexamine its state, and track the values of variables in a program.  Running a program step-by-step  This involves running a target program one \"line\" at a time, breaking at each\nnext \"line\" to observe the state of the program such as the values of variables\nin the stack frame. While line-by-line stepping is one of the most common and\nuseful forms of stepping through your program, some debuggers offer other step\nincrements such as frame-by-frame.  Newer debuggers like Scala IDE's  async debugger  offer the ability\nto step through your program even when the code execution path is not\nstraightforward (in this case when running distributed, message-driven programs\nusing the  Akka toolkit and runtime ).  Breaking a program to examine its state  This involves setting what is known as a breakpoint, a marker in a program\nindicating that you want to stop execution temporarily, to be able to examine\nthe running state of a program. Often, breakpoints are placed on specific\nsource lines of a program indicating that the developer wishes to stop the\nprogram when executing a specific line to examine the current state. Earlier\nbreakpoints would be placed on specific instructions (assembly).  Other forms of breakpoints can also exist including setting a conditional\nbreakpoint that triggers when reading/writing memory (watchpoints) or the\nevaluation of an expression yields true.  Watching variables in a program  When debugging a program, a common scenario is that a developer wants to\nknow when a variable's value is accessed or changed. This typically involves\nthe temporary suspension of the program allowing the developer to inspect the\ncurrent stack frame to understand what led to the access/modification of the\nvariable. Furthermore, more restrictions might be placed on the modification\nof a variable such that a developer is only notified when a variable is changed\nto a certain value, allowing more accurate understanding of specific problems\nsuch as when a variable unexpectedly becomes  null .  Evaluating expressions  A useful feature in many debuggers is the ability to evaluate an expression\n(snippet of code) in the target program while it is suspended due to a\nbreakpoint. This allows developers to quickly test functions and perform\nmodifications to the state of the program using the same language as the\nprogram itself.", 
            "title": "Features"
        }, 
        {
            "location": "/getting-started/what-is-a-debugger/#more-about-eclipse-and-how-it-relates-to-this-project", 
            "text": "The  Eclipse Debug Project  offers two subprojects for debugging with\nthe Eclipse tooling: platform debug and JDT debug. Platform debug focuses on\ndefining language-independent debugging capabilities including defining\nbreakpoints (see features for more info), launching programs, and\nnotification of events from target programs. JDT debug is more specific as it\nimplements the Java debugging support to launch or attach to a JVM, evaluate\nexpressions in the context of a stack frame, and dynamically reload classes\ninto the target JVM.  The underlying API driving Eclipse's debugging framework for Java (and other\nJVM-based languages) is the  Java Platform Debugger Architecture  (JPDA).\nThe JDPA is a collection of APIs to debug Java code and includes the Java Debug\nWire Protocol (JDWP) defining communication between the debugger and target\nJVMs, the Java Virtual Machine Tools Interface (JVMTI) providing a native\ninterface (C++) to inspect state and control execution of programs running in\na JVM, and the  Java Debugger Interface  ( JDI ) that defines a high-level\nAPI in Java to debug remote JVMs.  The Scala debugger API is built on top of the  JDI , wrapping existing  JDI \nfunctionality in Scala-friendly wrappers and providing higher-level\nabstractions to aid Scala developers in writing debugger tooling and utilize\ndebugger functionality in their own applications.", 
            "title": "More about Eclipse and how it relates to this project"
        }, 
        {
            "location": "/getting-started/installation/", 
            "text": "Installation\n\n\nHow to install the Scala debugger API.\n\n\n\n\nPrerequisites\n\n\nIn order to use the Scala debugger API, you need to have \ntools.jar\n available\n(provided by Oracle's JDK and OpenJDK). This is typically as simple as\ninstalling the JDK on your system.\n\n\nAt runtime, the Scala debugger API will attempt to load \ntools.jar\n from a\nvariety of locations including \nJDK_HOME\n, \nJAVA_HOME\n, and the system\nproperty \njava.home\n. If the Scala debugger API has issues loading \ntools.jar\n,\nyou should set either \nJD_HOME\n or \nJAVA_HOME\n to the path to your JDK.\n\n\nMac OS X users can locate their active JDK version using\n\n/usr/libexec/java_home\n.\n\n\n\n\nLinux users can locate their active JDK using \nls -l `which javac`\n to\nlocate the directory containing the compiler and looking one directory up.\n\n\n\n\nInstalling the library\n\n\nThe Scala debugger library is available on Maven Central, which means that you\ncan install it using sbt:\n\n\nlibraryDependencies += \norg.scala-debugger\n %% \nscala-debugger-api\n % \n1.0.0\n\n\n\n\n\nTo be able to compile code using the \nJDI\n, you need to also add this plugin to\nyour \nproject/plugins.sbt\n file:\n\n\naddSbtPlugin(\norg.scala-debugger\n % \nsbt-jdi-tools\n % \n1.0.0\n)\n\n\n\n\nThe Scala debugger API is currently available for Scala 2.10 and Scala 2.11.\n\n\nVerifying it works\n\n\n\n\nCreate a new project using the Scala debugger API (see\n   \ninstalling the library\n for setting it up).\n\n\nUse \nJDITools.isJdiAvailable()\n to determine if \nJDI\n classes are available\n   or on your path via \ntools.jar\n.\n\n\nUse \nJDITools.tryLoadJdi()\n to load the \nJDI\n classes into your system\n   classloader.\n\n\n\n\nSee the sample below for a working example:\n\n\nimport org.scaladebugger.api.utils.JDITools\n\nobject VerifyLibrary extends App {\n  // Checks if the JDI is available in your runtime\n  // classloader or by extracting it from tools.jar\n  // found in JDK_HOME or JAVA_HOME\n  println(\nJDI is available: \n + JDITools.isJdiAvailable())\n\n  // Loads the JDI from tools.jar and attempts to\n  // add it to your system classloader\n  println(\nLoaded JDI: \n + JDITools.tryLoadJdi())\n}", 
            "title": "Installation"
        }, 
        {
            "location": "/getting-started/installation/#installation", 
            "text": "How to install the Scala debugger API.", 
            "title": "Installation"
        }, 
        {
            "location": "/getting-started/installation/#prerequisites", 
            "text": "In order to use the Scala debugger API, you need to have  tools.jar  available\n(provided by Oracle's JDK and OpenJDK). This is typically as simple as\ninstalling the JDK on your system.  At runtime, the Scala debugger API will attempt to load  tools.jar  from a\nvariety of locations including  JDK_HOME ,  JAVA_HOME , and the system\nproperty  java.home . If the Scala debugger API has issues loading  tools.jar ,\nyou should set either  JD_HOME  or  JAVA_HOME  to the path to your JDK.  Mac OS X users can locate their active JDK version using /usr/libexec/java_home .   Linux users can locate their active JDK using  ls -l `which javac`  to\nlocate the directory containing the compiler and looking one directory up.", 
            "title": "Prerequisites"
        }, 
        {
            "location": "/getting-started/installation/#installing-the-library", 
            "text": "The Scala debugger library is available on Maven Central, which means that you\ncan install it using sbt:  libraryDependencies +=  org.scala-debugger  %%  scala-debugger-api  %  1.0.0   To be able to compile code using the  JDI , you need to also add this plugin to\nyour  project/plugins.sbt  file:  addSbtPlugin( org.scala-debugger  %  sbt-jdi-tools  %  1.0.0 )  The Scala debugger API is currently available for Scala 2.10 and Scala 2.11.", 
            "title": "Installing the library"
        }, 
        {
            "location": "/getting-started/installation/#verifying-it-works", 
            "text": "Create a new project using the Scala debugger API (see\n    installing the library  for setting it up).  Use  JDITools.isJdiAvailable()  to determine if  JDI  classes are available\n   or on your path via  tools.jar .  Use  JDITools.tryLoadJdi()  to load the  JDI  classes into your system\n   classloader.   See the sample below for a working example:  import org.scaladebugger.api.utils.JDITools\n\nobject VerifyLibrary extends App {\n  // Checks if the JDI is available in your runtime\n  // classloader or by extracting it from tools.jar\n  // found in JDK_HOME or JAVA_HOME\n  println( JDI is available:   + JDITools.isJdiAvailable())\n\n  // Loads the JDI from tools.jar and attempts to\n  // add it to your system classloader\n  println( Loaded JDI:   + JDITools.tryLoadJdi())\n}", 
            "title": "Verifying it works"
        }, 
        {
            "location": "/getting-started/available-debugger-connections/", 
            "text": "Available Debugger Connections\n\n\nIn this section, you will get a brief overview of the available options for\nconnecting a debugger programmatically to one or more target JVMs.\n\n\n\n\nOverview\n\n\nWhen you want to debug a JVM, you need to establish some form of communication\nbetween the target JVM, the one you want to debug, and the debugger, the\nJVM used to perform the debugging. When using the Java Debugger Interface,\nthere is an abstraction called a \nconnector\n that is used when\nestablishing the connection between a debugger application (using \nJDI\n) and the\ntarget JVM.\n\n\nThe two common means of transport are socket-based and memory-based. As the\nshared memory transport is limited to Windows, all of the connectors available\nin the Scala debugger API use connectors that use socket transportation.\n\n\nThe three most common ways to establish a connection between the debugger and\na target JVM are to launch the target JVM and connect to it, to attach to an\nalready-running JVM, or to listen for connections from target JVMs.\n\n\nBelow, you will read about these three methods of starting communication with\na target JVM and how you can perform these using the Scala debugger API.\n\n\nLaunching Debugger\n\n\nThe launching debugger is the commonly-used method in IDEs like Scala IDE and\nIntelliJ when you have a program that you both want to start and debug.\n\n\nInstantiating\n\n\nTo create the launching debugger using the Scala debugger API, you instantiate\na new instance of the debugger using the companion object:\n\n\nval launchingDebugger = LaunchingDebugger(className = \nsome.class.name\n)\n\n\n\n\nThe only required argument for the launching debugger is the fully-qualified\nclass name that you want to use as the entrypoint for the target JVM. The\ncurrent classpath of the debugger is used when launching the target JVM; so,\nthe specified class must exist in your current classpath.\n\n\nThe launching debugger can also take additional arguments including command\nline options to pass to the main method, jvm options to provide to the target\nJVM when started, and a flag indicating whether or not to suspend the target\nJVM until the debugger has connected to it.\n\n\nStarting\n\n\nWhen you are ready to launch the target JVM using the provided class as the\nentrypoint to the target JVM, call the \nstart\n method.\n\n\nlaunchingDebugger.start { s =\n\n  println(\nLaunched and connected to JVM: \n + s.uniqueId)\n}\n\n\n\n\nWhen you call \nstart\n with the launching debugger, you provide a function that\ntakes a \nScalaVirtualMachine\n as an argument. This is treated as a callback\nthat is invoked when the launching debugger connects to the started target JVM\nprocess.\n\n\nStopping\n\n\nTo stop the launching debugger, you can call the \nstop\n function:\n\n\nlaunchingDebugger.stop()\n\n\n\n\nThis kills the target JVM process and stops the debugger.\n\n\nCookbook\n\n\nThe \nScalaVirtualMachine\n contains the majority of debugger-related functions\nthat you can use to invoke \nJDI\n operations.\n\n\nSee the \ncookbook\n for a full example.\n\n\nAttaching Debugger\n\n\nThe attaching debugger is the next most-used method in IDEs like Scala IDE and\nIntelliJ when you have the source code for the target JVM loaded up but want to\nconnect to an already-running JVM process.\n\n\nIt begins with the target JVM already running with the necessary JDWP arguments\nto expose a TCP port that the debugger will use to connect (attach):\n\n\n# Allow debuggers to attach via port 5005\n-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=5005\n\n\n\n\nInstantiating\n\n\nTo create the attaching debugger using the Scala debugger API, you instantiate\na new instance of the debugger using the companion object:\n\n\nval attachingDebugger = AttachingDebugger(port = 5005)\n\n\n\n\nThe only required argument for the attaching debugger is the port that the\ndebugger will use when connecting to the target JVM. This port should match the\nport you provided in the JDWP arguments to the target JVM when starting it on\nyour own.\n\n\nThe attaching debugger can also take additional arguments including the hostname\nused when connecting to the target JVM (defaulting to localhost) and the maximum\ntime to wait (in milliseconds) for a successful connection before timing out.\n\n\nStarting\n\n\nWhen you are ready to attach to the target JVM, call the \nstart\n method.\n\n\nattachingDebugger.start { s =\n\n  println(\nAttached to JVM: \n + s.uniqueId)\n}\n\n\n\n\nAs with the launching debugger, when you call \nstart\n, you provide a function\nthat takes a \nScalaVirtualMachine\n as an argument. This function is treated as\na callback that is invoked when the attaching debugger connects to the target\nJVM process.\n\n\nStopping\n\n\nTo stop the attaching debugger, you can call the \nstop\n function:\n\n\nattachingDebugger.stop()\n\n\n\n\nThis disconnects from the target JVM and stops the debugger. The target JVM\nwill continue to run and, if suspended, should resume normal execution.\n\n\nCookbook\n\n\nSee the \ncookbook\n for a full example.\n\n\nListening Debugger\n\n\nThe listening debugger is less frequently used as it offers the opposite mode\nof connecting. While the launching and attaching debuggers serve to perform the\nconnection themselves, the listening debugger merely waits for target JVMs to\nconnect to it.\n\n\n# Connect to a listening debugger via port 5005\n-agentlib:jdwp=transport=dt_socket,server=n,suspend=n,address=5005\n\n\n\n\n\n\nNote:\n\n\nThe listening debugger is often capable of supporting more than one target\nJVM connecting at once. This means that you could have a single debugger\nprocess managing multiple target JVMs such as with a cluster setup.\n\n\n\n\nInstantiating\n\n\nTo create the listening debugger using the Scala debugger API, you instantiate\na new instance of the debugger using the companion object:\n\n\nval listeningDebugger = ListeningDebugger(port = 5005)\n\n\n\n\nThe only required argument for the listening debugger is the port that the\ndebugger will use to listen for incoming connections from target JVMs. This\nport should match the port you provid in the JDWP arguments to the target\nJVMs when starting them. The debugger itself should be started before the\ntarget JVMs as the target JVMs only try to connect once.\n\n\nThe listening debugger can also take additional arguments including the hostname\nto bind to when listening for connections (defaulting to localhost) and the\nnumber of worker threads to use when processing new JVM connections (defaulting\nto a single thread).\n\n\nStarting\n\n\nWhen you are ready to begin listening for target JVMs, call the \nstart\n method.\n\n\nlisteningDebugger.start { s =\n\n  println(\nReceived connection from JVM: \n + s.uniqueId)\n}\n\n\n\n\nWhile the listening debugger's \nstart\n method does take a callback function\nlike the other two debuggers, this function can be invoked more than once. For\neach connection with a target JVM that the debugger receives, it will invoke\nthe callback and pass it the \nScalaVirtualMachine\n instance representing the\nnew connection.\n\n\nStopping\n\n\nTo stop the listening debugger, you can call the \nstop\n function:\n\n\nlisteningDebugger.stop()\n\n\n\n\nThis stops the debugger from listening for JVM connections. The target JVMs\nthat were connected will continue to run and, if suspended, should resume\nnormal execution.\n\n\nCookbook\n\n\nSee the \ncookbook\n for a full example.", 
            "title": "Available Debugger Connections"
        }, 
        {
            "location": "/getting-started/available-debugger-connections/#available-debugger-connections", 
            "text": "In this section, you will get a brief overview of the available options for\nconnecting a debugger programmatically to one or more target JVMs.", 
            "title": "Available Debugger Connections"
        }, 
        {
            "location": "/getting-started/available-debugger-connections/#overview", 
            "text": "When you want to debug a JVM, you need to establish some form of communication\nbetween the target JVM, the one you want to debug, and the debugger, the\nJVM used to perform the debugging. When using the Java Debugger Interface,\nthere is an abstraction called a  connector  that is used when\nestablishing the connection between a debugger application (using  JDI ) and the\ntarget JVM.  The two common means of transport are socket-based and memory-based. As the\nshared memory transport is limited to Windows, all of the connectors available\nin the Scala debugger API use connectors that use socket transportation.  The three most common ways to establish a connection between the debugger and\na target JVM are to launch the target JVM and connect to it, to attach to an\nalready-running JVM, or to listen for connections from target JVMs.  Below, you will read about these three methods of starting communication with\na target JVM and how you can perform these using the Scala debugger API.", 
            "title": "Overview"
        }, 
        {
            "location": "/getting-started/available-debugger-connections/#launching-debugger", 
            "text": "The launching debugger is the commonly-used method in IDEs like Scala IDE and\nIntelliJ when you have a program that you both want to start and debug.  Instantiating  To create the launching debugger using the Scala debugger API, you instantiate\na new instance of the debugger using the companion object:  val launchingDebugger = LaunchingDebugger(className =  some.class.name )  The only required argument for the launching debugger is the fully-qualified\nclass name that you want to use as the entrypoint for the target JVM. The\ncurrent classpath of the debugger is used when launching the target JVM; so,\nthe specified class must exist in your current classpath.  The launching debugger can also take additional arguments including command\nline options to pass to the main method, jvm options to provide to the target\nJVM when started, and a flag indicating whether or not to suspend the target\nJVM until the debugger has connected to it.  Starting  When you are ready to launch the target JVM using the provided class as the\nentrypoint to the target JVM, call the  start  method.  launchingDebugger.start { s = \n  println( Launched and connected to JVM:   + s.uniqueId)\n}  When you call  start  with the launching debugger, you provide a function that\ntakes a  ScalaVirtualMachine  as an argument. This is treated as a callback\nthat is invoked when the launching debugger connects to the started target JVM\nprocess.  Stopping  To stop the launching debugger, you can call the  stop  function:  launchingDebugger.stop()  This kills the target JVM process and stops the debugger.  Cookbook  The  ScalaVirtualMachine  contains the majority of debugger-related functions\nthat you can use to invoke  JDI  operations.  See the  cookbook  for a full example.", 
            "title": "Launching Debugger"
        }, 
        {
            "location": "/getting-started/available-debugger-connections/#attaching-debugger", 
            "text": "The attaching debugger is the next most-used method in IDEs like Scala IDE and\nIntelliJ when you have the source code for the target JVM loaded up but want to\nconnect to an already-running JVM process.  It begins with the target JVM already running with the necessary JDWP arguments\nto expose a TCP port that the debugger will use to connect (attach):  # Allow debuggers to attach via port 5005\n-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=5005  Instantiating  To create the attaching debugger using the Scala debugger API, you instantiate\na new instance of the debugger using the companion object:  val attachingDebugger = AttachingDebugger(port = 5005)  The only required argument for the attaching debugger is the port that the\ndebugger will use when connecting to the target JVM. This port should match the\nport you provided in the JDWP arguments to the target JVM when starting it on\nyour own.  The attaching debugger can also take additional arguments including the hostname\nused when connecting to the target JVM (defaulting to localhost) and the maximum\ntime to wait (in milliseconds) for a successful connection before timing out.  Starting  When you are ready to attach to the target JVM, call the  start  method.  attachingDebugger.start { s = \n  println( Attached to JVM:   + s.uniqueId)\n}  As with the launching debugger, when you call  start , you provide a function\nthat takes a  ScalaVirtualMachine  as an argument. This function is treated as\na callback that is invoked when the attaching debugger connects to the target\nJVM process.  Stopping  To stop the attaching debugger, you can call the  stop  function:  attachingDebugger.stop()  This disconnects from the target JVM and stops the debugger. The target JVM\nwill continue to run and, if suspended, should resume normal execution.  Cookbook  See the  cookbook  for a full example.", 
            "title": "Attaching Debugger"
        }, 
        {
            "location": "/getting-started/available-debugger-connections/#listening-debugger", 
            "text": "The listening debugger is less frequently used as it offers the opposite mode\nof connecting. While the launching and attaching debuggers serve to perform the\nconnection themselves, the listening debugger merely waits for target JVMs to\nconnect to it.  # Connect to a listening debugger via port 5005\n-agentlib:jdwp=transport=dt_socket,server=n,suspend=n,address=5005   Note:  The listening debugger is often capable of supporting more than one target\nJVM connecting at once. This means that you could have a single debugger\nprocess managing multiple target JVMs such as with a cluster setup.   Instantiating  To create the listening debugger using the Scala debugger API, you instantiate\na new instance of the debugger using the companion object:  val listeningDebugger = ListeningDebugger(port = 5005)  The only required argument for the listening debugger is the port that the\ndebugger will use to listen for incoming connections from target JVMs. This\nport should match the port you provid in the JDWP arguments to the target\nJVMs when starting them. The debugger itself should be started before the\ntarget JVMs as the target JVMs only try to connect once.  The listening debugger can also take additional arguments including the hostname\nto bind to when listening for connections (defaulting to localhost) and the\nnumber of worker threads to use when processing new JVM connections (defaulting\nto a single thread).  Starting  When you are ready to begin listening for target JVMs, call the  start  method.  listeningDebugger.start { s = \n  println( Received connection from JVM:   + s.uniqueId)\n}  While the listening debugger's  start  method does take a callback function\nlike the other two debuggers, this function can be invoked more than once. For\neach connection with a target JVM that the debugger receives, it will invoke\nthe callback and pass it the  ScalaVirtualMachine  instance representing the\nnew connection.  Stopping  To stop the listening debugger, you can call the  stop  function:  listeningDebugger.stop()  This stops the debugger from listening for JVM connections. The target JVMs\nthat were connected will continue to run and, if suspended, should resume\nnormal execution.  Cookbook  See the  cookbook  for a full example.", 
            "title": "Listening Debugger"
        }, 
        {
            "location": "/getting-started/event-pipelines/", 
            "text": "Event Pipelines\n\n\n\n\nOverview\n\n\nA pipeline, as its name implies, is used to build a series of operations\n(chain a collection of functions) to be evaluated whenever data is processed\nthrough the pipeline. With regard to the Scala debugger API, this occurs\nwhenever an event associated with the pipeline occurs.\n\n\nEvent pipelines are a key component of the high-level API available in the\nScala debugger API. Methods like \nonUnsafeBreakpoint\n and\n\nonUnsafeAccessWatchpoint\n return pipelines directly while \nonBreakpoint\n and\n\nonAccessWatchpoint\n return a \nTry\n whose success is a pipeline. See the\nother sections and the Scaladoc for more information on individual methods.\n\n\nExample of Pipeline\n\n\nA pipeline of \nBreakpointEvent\n objects will typically be\ntriggered whenever a breakpoint on the target JVM is hit. When that occurs,\nall operations applied to the pipeline will be evaluated in sequential order.\n\n\nval s: ScalaVirtualMachine = /* some virtual machine */\n\n// This creates a new pipeline for a breakpoint\nval pipeline: IdentityPipeline[BreakpointEvent] = s.onUnsafeBreakpoint(\nsome/scala/file.scala\n, 37)\n\n// Triggers whenever a breakpoint is hit\npipeline.foreach(_ =\n println(\nA breakpoint occurred!\n))\n\n// Triggers explicitly when line 37 of any file is hit\npipeline.map(_.location().lineNumber()).filter(_ == 37).foreach(_ =\n println(\nLine 37 was hit!\n))\n\n\n\n\nIn the example above, a pipeline was created for a specific breakpoint. From\nthere, two children pipelines were created: one that is triggered whenever a\nbreakpoint occurs and one that is only \nfully\n evaluated when a breakpoint\noccurs on line 37.\n\n\nWhat can I do with a pipeline?\n\n\nA pipeline has the following operations available:\n\n\n\n\n\n\n\n\nMethod\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nmap\n\n\nTransforms each element in the pipeline to something else.\n\n\n\n\n\n\nflatMap\n\n\nTransforms each element in the pipeline to something else and flattens it.\n\n\n\n\n\n\nfilter\n\n\nFilters the pipeline to only continue evaluating elements that yield true.\n\n\n\n\n\n\nfilterNot\n\n\nFilters the pipeline to only continue evaluating elements that yield false.\n\n\n\n\n\n\nforeach\n\n\nPerforms some action on each element in the pipeline.\n\n\n\n\n\n\ntransform\n\n\nTransforms the operation of a pipeline to another operation.\n\n\n\n\n\n\nunionInput\n\n\nCombines the input of two pipelines into one new pipeline.\n\n\n\n\n\n\nunionOutput\n\n\nCombines the output of two pipelines into one new pipeline.\n\n\n\n\n\n\nnoop\n\n\nDoes nothing to the pipeline elements. Just passes them down the chain.\n\n\n\n\n\n\nmetadata\n\n\nCombines the current pipeline data with its metadata.\n\n\n\n\n\n\nfailed\n\n\nTriggered when the pipeline fails to process at this specific stage.\n\n\n\n\n\n\nwithMetadata\n\n\nAdds additional metadata to be associated with the new pipeline.\n\n\n\n\n\n\nclose\n\n\nCloses the pipeline so no new elements get processed by it.\n\n\n\n\n\n\ntoFuture\n\n\nConverts the pipeline to a future, evaluated on the next element and then closed.\n\n\n\n\n\n\nprocess\n\n\nProcesses the provided data through the pipeline.\n\n\n\n\n\n\ncurrentMetadata\n\n\nReturns the metadata at this stage in the pipeline.\n\n\n\n\n\n\n\n\nWarning on closing pipelines\n\n\nWhen closing pipelines for events, the underlying event handlers that\nfunnel events through the pipelines are removed; however, the request\nto send event data from the target JVM to the debugger still exists until\n\nALL\n pipelines associated with the request are closed!\n\n\nYou can avoid this problem by providing close with the \nCloseRemoveAll\n flag.\nThis will remove the request and all underlying event handlers. This means\nthat any other pipeline created for the request will also stop receiving\nevents.\n\n\nval p: IdentityPipeline[BreakpointEvent] = /* some breakpoint pipeline */\n\n// Remove the request and ALL underlying event handlers\nimport org.scaladebugger.api.profiles.Constants.CloseRemoveAll\np.close(data = CloseRemoveAll)", 
            "title": "Event Pipelines"
        }, 
        {
            "location": "/getting-started/event-pipelines/#event-pipelines", 
            "text": "", 
            "title": "Event Pipelines"
        }, 
        {
            "location": "/getting-started/event-pipelines/#overview", 
            "text": "A pipeline, as its name implies, is used to build a series of operations\n(chain a collection of functions) to be evaluated whenever data is processed\nthrough the pipeline. With regard to the Scala debugger API, this occurs\nwhenever an event associated with the pipeline occurs.  Event pipelines are a key component of the high-level API available in the\nScala debugger API. Methods like  onUnsafeBreakpoint  and onUnsafeAccessWatchpoint  return pipelines directly while  onBreakpoint  and onAccessWatchpoint  return a  Try  whose success is a pipeline. See the\nother sections and the Scaladoc for more information on individual methods.", 
            "title": "Overview"
        }, 
        {
            "location": "/getting-started/event-pipelines/#example-of-pipeline", 
            "text": "A pipeline of  BreakpointEvent  objects will typically be\ntriggered whenever a breakpoint on the target JVM is hit. When that occurs,\nall operations applied to the pipeline will be evaluated in sequential order.  val s: ScalaVirtualMachine = /* some virtual machine */\n\n// This creates a new pipeline for a breakpoint\nval pipeline: IdentityPipeline[BreakpointEvent] = s.onUnsafeBreakpoint( some/scala/file.scala , 37)\n\n// Triggers whenever a breakpoint is hit\npipeline.foreach(_ =  println( A breakpoint occurred! ))\n\n// Triggers explicitly when line 37 of any file is hit\npipeline.map(_.location().lineNumber()).filter(_ == 37).foreach(_ =  println( Line 37 was hit! ))  In the example above, a pipeline was created for a specific breakpoint. From\nthere, two children pipelines were created: one that is triggered whenever a\nbreakpoint occurs and one that is only  fully  evaluated when a breakpoint\noccurs on line 37.", 
            "title": "Example of Pipeline"
        }, 
        {
            "location": "/getting-started/event-pipelines/#what-can-i-do-with-a-pipeline", 
            "text": "A pipeline has the following operations available:     Method  Description      map  Transforms each element in the pipeline to something else.    flatMap  Transforms each element in the pipeline to something else and flattens it.    filter  Filters the pipeline to only continue evaluating elements that yield true.    filterNot  Filters the pipeline to only continue evaluating elements that yield false.    foreach  Performs some action on each element in the pipeline.    transform  Transforms the operation of a pipeline to another operation.    unionInput  Combines the input of two pipelines into one new pipeline.    unionOutput  Combines the output of two pipelines into one new pipeline.    noop  Does nothing to the pipeline elements. Just passes them down the chain.    metadata  Combines the current pipeline data with its metadata.    failed  Triggered when the pipeline fails to process at this specific stage.    withMetadata  Adds additional metadata to be associated with the new pipeline.    close  Closes the pipeline so no new elements get processed by it.    toFuture  Converts the pipeline to a future, evaluated on the next element and then closed.    process  Processes the provided data through the pipeline.    currentMetadata  Returns the metadata at this stage in the pipeline.", 
            "title": "What can I do with a pipeline?"
        }, 
        {
            "location": "/getting-started/event-pipelines/#warning-on-closing-pipelines", 
            "text": "When closing pipelines for events, the underlying event handlers that\nfunnel events through the pipelines are removed; however, the request\nto send event data from the target JVM to the debugger still exists until ALL  pipelines associated with the request are closed!  You can avoid this problem by providing close with the  CloseRemoveAll  flag.\nThis will remove the request and all underlying event handlers. This means\nthat any other pipeline created for the request will also stop receiving\nevents.  val p: IdentityPipeline[BreakpointEvent] = /* some breakpoint pipeline */\n\n// Remove the request and ALL underlying event handlers\nimport org.scaladebugger.api.profiles.Constants.CloseRemoveAll\np.close(data = CloseRemoveAll)", 
            "title": "Warning on closing pipelines"
        }, 
        {
            "location": "/getting-started/working-with-breakpoints/", 
            "text": "Working with Breakpoints\n\n\n\n\nOverview\n\n\nThe following will provide you with a brief overview of creating breakpoints,\nchaining together reactions to breakpoint events, and removing breakpoints.\n\n\nCreating\n\n\nThe Scala debugger API provides a simple way to create breakpoints in your\ndebugger application. Given a \nScalaVirtualMachine\n instance, you can execute\nthe \nonBreakpoint\n or \nonUnsafeBreakpoint\n method to place a breakpoint on the\nspecified file and line number.\n\n\nval s: ScalaVirtualMachine = /* some virtual machine */\ns.onUnsafeBreakpoint(\nsome/scala/file.scala\n, 37)\n\n\n\n\nYou do not need to worry about creating the same breakpoint over and over\nwhen calling \nonBreakpoint\n or \nonUnsafeBreakpoint\n. These methods cache\nyour request based on the provided arguments. So, you can reference the\nsame breakpoint multiple times.\n\n\nThe difference between safe and unsafe operations is that the unsafe operation\nwill throw an exception if an error occurs that prevents the breakpoint from\nbeing created while the safe operation will wrap the error in a \nTry\n object.\n\n\n\n\nNote:\n\n\nThe file name of the breakpoint must be the ACTUAL file name, not the\nclass name. Since Scala allows you to have classes in files whose names\ndo not match, you need to make sure that the breakpoint uses the name of\nthe file containing the class.\n\n\nFor example, the class \norg.scaladebugger.api.utils.LoopingTask\n is\nlocated in the file \norg/scaladebugger/api/utils/LoopingTaskRunner.scala\n\nand would use that full file path as the file name of the breakpoint.\n\n\n\n\nPipelining\n\n\nOnce you have created a breakpoint, you can chain together a pipeline of\nfunctions that you want to execute when the breakpoint is hit. These functions\nare consistent with standard Scala \nmap\n, \nflatMap\n, and \nforeach\n structure.\n\n\nval s: ScalaVirtualMachine = /* some virtual machine */\ns.onUnsafeBreakpoint(\nsome/scala/file.scala\n, 37).foreach(_ =\n println(\nHit line 37!\n))\n\n\n\n\nRemoving\n\n\nWhenever you are finished with the breakpoint, you can remove it by closing the\nassociated pipeline.\n\n\nval s: ScalaVirtualMachine = /* some virtual machine */\nval bp = s.onUnsafeBreakpoint(\nsome/scala/file.scala\n, 37)\n\nbp.foreach(_ =\n println(\nHit line 37!\n))\n\nimport org.scaladebugger.api.profiles.Constants.CloseRemoveAll\nbp.close(data = CloseRemoveAll)\n\n\n\n\n\n\nWarning:\n\n\nCurrently, you must provide close with the flag \nCloseRemoveAll\n in order\nto remove the request and any underlying event handlers.\n\n\nSpecifying close without that flag will only stop events going through\nthat specific pipeline. If all pipelines associated with a request are\nclosed, the request will also be removed.\n\n\n\n\nBy default, \nclose\n will be triggered immediately. Alternatively, you can\ninvoke \nclose\n with \nnow = false\n to close the pipeline once the next\nevent occurs.\n\n\nCookbook\n\n\nSee the \ncookbook\n for a working example.", 
            "title": "Working with Breakpoints"
        }, 
        {
            "location": "/getting-started/working-with-breakpoints/#working-with-breakpoints", 
            "text": "", 
            "title": "Working with Breakpoints"
        }, 
        {
            "location": "/getting-started/working-with-breakpoints/#overview", 
            "text": "The following will provide you with a brief overview of creating breakpoints,\nchaining together reactions to breakpoint events, and removing breakpoints.", 
            "title": "Overview"
        }, 
        {
            "location": "/getting-started/working-with-breakpoints/#creating", 
            "text": "The Scala debugger API provides a simple way to create breakpoints in your\ndebugger application. Given a  ScalaVirtualMachine  instance, you can execute\nthe  onBreakpoint  or  onUnsafeBreakpoint  method to place a breakpoint on the\nspecified file and line number.  val s: ScalaVirtualMachine = /* some virtual machine */\ns.onUnsafeBreakpoint( some/scala/file.scala , 37)  You do not need to worry about creating the same breakpoint over and over\nwhen calling  onBreakpoint  or  onUnsafeBreakpoint . These methods cache\nyour request based on the provided arguments. So, you can reference the\nsame breakpoint multiple times.  The difference between safe and unsafe operations is that the unsafe operation\nwill throw an exception if an error occurs that prevents the breakpoint from\nbeing created while the safe operation will wrap the error in a  Try  object.   Note:  The file name of the breakpoint must be the ACTUAL file name, not the\nclass name. Since Scala allows you to have classes in files whose names\ndo not match, you need to make sure that the breakpoint uses the name of\nthe file containing the class.  For example, the class  org.scaladebugger.api.utils.LoopingTask  is\nlocated in the file  org/scaladebugger/api/utils/LoopingTaskRunner.scala \nand would use that full file path as the file name of the breakpoint.", 
            "title": "Creating"
        }, 
        {
            "location": "/getting-started/working-with-breakpoints/#pipelining", 
            "text": "Once you have created a breakpoint, you can chain together a pipeline of\nfunctions that you want to execute when the breakpoint is hit. These functions\nare consistent with standard Scala  map ,  flatMap , and  foreach  structure.  val s: ScalaVirtualMachine = /* some virtual machine */\ns.onUnsafeBreakpoint( some/scala/file.scala , 37).foreach(_ =  println( Hit line 37! ))", 
            "title": "Pipelining"
        }, 
        {
            "location": "/getting-started/working-with-breakpoints/#removing", 
            "text": "Whenever you are finished with the breakpoint, you can remove it by closing the\nassociated pipeline.  val s: ScalaVirtualMachine = /* some virtual machine */\nval bp = s.onUnsafeBreakpoint( some/scala/file.scala , 37)\n\nbp.foreach(_ =  println( Hit line 37! ))\n\nimport org.scaladebugger.api.profiles.Constants.CloseRemoveAll\nbp.close(data = CloseRemoveAll)   Warning:  Currently, you must provide close with the flag  CloseRemoveAll  in order\nto remove the request and any underlying event handlers.  Specifying close without that flag will only stop events going through\nthat specific pipeline. If all pipelines associated with a request are\nclosed, the request will also be removed.   By default,  close  will be triggered immediately. Alternatively, you can\ninvoke  close  with  now = false  to close the pipeline once the next\nevent occurs.", 
            "title": "Removing"
        }, 
        {
            "location": "/getting-started/working-with-breakpoints/#cookbook", 
            "text": "See the  cookbook  for a working example.", 
            "title": "Cookbook"
        }, 
        {
            "location": "/getting-started/stepping-through-code/", 
            "text": "Stepping through Code\n\n\n\n\nOverview\n\n\nThe following will provide you with a brief overview of stepping into, over,\nand out of lines of code in a target JVM.\n\n\nRequirements\n\n\nIn order to step through your code, you need to be in a suspended state in your\ntarget JVM. This typically means that you have placed a breakpoint somewhere in\nyour target JVM, hit it, and want to begin stepping from that location.\n\n\nIn the explanation below, you will see examples using breakpoints as a means to\nreach a state where you can begin stepping through your JVM.\n\n\nWhen stepping into, over, or out of lines/frames in your target JVM, you need\nto be able to provide a thread reference (a \nJDI\n structure) to indicate which\nsuspended thread will step forward.\n\n\nPerforming a step\n\n\nPerforming a step is a very simple process. First, you need to make sure that\nyour target JVM is in a state where it can perform a step. This means that the\nthread where the step will be performed needs to be suspended. The easiest way\nto achieve this state in the location where you want to start is to set a\nbreakpoint and step as a reaction when a breakpoint occurs.\n\n\nval s: ScalaVirtualMachine = /* some virtual machine */\nval fileName: String = /* desired starting file location */\nval lineNumber: Int = /* desired starting line location */\n\ns.onUnsafeBreakpoint(fileName, lineNumber).foreach(be =\n {\n  val path = be.location().sourcePath()\n  val line = be.location().lineNumber()\n\n  println(s\nReached breakpoint for $path:$line\n)\n\n  /* Step code would go here */\n})\n\n\n\n\nOnce you are ready to perform a step, you need to decide what kind of step you\nwould like to perform. The Scala debugger API supports six kinds of steps:\n\n\n\n\nStep into a line of code: \nstepIntoLine\n\n\nStep over a line of code: \nstepOverLine\n\n\nStep out of a line of code: \nstepOutLine\n\n\nStep into a frame: \nstepIntoMin\n\n\nStep over a frame: \nstepOverMin\n\n\nStep out of a frame: \nstepOutMin\n\n\n\n\nThe more common step types are associated with lines of code, rather than\nstack frames. All of these methods return a future that is completed when the\nstep operation has completed. Each of these methods also requires you to\nprovide a \nThreadReference\n where the step will occur. You\ncan acquire the reference to the thread where a breakpoint occurred from the\nbreakpoint event as seen in the example below.\n\n\nval be: BreakpointEvent = /* Breakpoint event from above code example */\n\n// Step methods return a future that occurs when the step finishes\nimport scala.concurrent.ExecutionContext.Implicits.global\ns.stepOverLine(be.thread()).foreach(se =\n {\n  val path = se.location().sourcePath()\n  val line = se.location().lineNumber()\n\n  println(s\nStepped to $path:$line\n)\n})\n\n\n\n\nCookbook\n\n\nSee the \ncookbook\n for a working example.", 
            "title": "Stepping through Code"
        }, 
        {
            "location": "/getting-started/stepping-through-code/#stepping-through-code", 
            "text": "", 
            "title": "Stepping through Code"
        }, 
        {
            "location": "/getting-started/stepping-through-code/#overview", 
            "text": "The following will provide you with a brief overview of stepping into, over,\nand out of lines of code in a target JVM.", 
            "title": "Overview"
        }, 
        {
            "location": "/getting-started/stepping-through-code/#requirements", 
            "text": "In order to step through your code, you need to be in a suspended state in your\ntarget JVM. This typically means that you have placed a breakpoint somewhere in\nyour target JVM, hit it, and want to begin stepping from that location.  In the explanation below, you will see examples using breakpoints as a means to\nreach a state where you can begin stepping through your JVM.  When stepping into, over, or out of lines/frames in your target JVM, you need\nto be able to provide a thread reference (a  JDI  structure) to indicate which\nsuspended thread will step forward.", 
            "title": "Requirements"
        }, 
        {
            "location": "/getting-started/stepping-through-code/#performing-a-step", 
            "text": "Performing a step is a very simple process. First, you need to make sure that\nyour target JVM is in a state where it can perform a step. This means that the\nthread where the step will be performed needs to be suspended. The easiest way\nto achieve this state in the location where you want to start is to set a\nbreakpoint and step as a reaction when a breakpoint occurs.  val s: ScalaVirtualMachine = /* some virtual machine */\nval fileName: String = /* desired starting file location */\nval lineNumber: Int = /* desired starting line location */\n\ns.onUnsafeBreakpoint(fileName, lineNumber).foreach(be =  {\n  val path = be.location().sourcePath()\n  val line = be.location().lineNumber()\n\n  println(s Reached breakpoint for $path:$line )\n\n  /* Step code would go here */\n})  Once you are ready to perform a step, you need to decide what kind of step you\nwould like to perform. The Scala debugger API supports six kinds of steps:   Step into a line of code:  stepIntoLine  Step over a line of code:  stepOverLine  Step out of a line of code:  stepOutLine  Step into a frame:  stepIntoMin  Step over a frame:  stepOverMin  Step out of a frame:  stepOutMin   The more common step types are associated with lines of code, rather than\nstack frames. All of these methods return a future that is completed when the\nstep operation has completed. Each of these methods also requires you to\nprovide a  ThreadReference  where the step will occur. You\ncan acquire the reference to the thread where a breakpoint occurred from the\nbreakpoint event as seen in the example below.  val be: BreakpointEvent = /* Breakpoint event from above code example */\n\n// Step methods return a future that occurs when the step finishes\nimport scala.concurrent.ExecutionContext.Implicits.global\ns.stepOverLine(be.thread()).foreach(se =  {\n  val path = se.location().sourcePath()\n  val line = se.location().lineNumber()\n\n  println(s Stepped to $path:$line )\n})", 
            "title": "Performing a step"
        }, 
        {
            "location": "/getting-started/stepping-through-code/#cookbook", 
            "text": "See the  cookbook  for a working example.", 
            "title": "Cookbook"
        }, 
        {
            "location": "/getting-started/watching-class-variables/", 
            "text": "Working with watchpoints\n\n\n\n\nOverview\n\n\nThe following will provide you with a brief overview of creating watchpoints,\nchaining together reactions to watchpoint events, and removing watchpoints.\n\n\nCreating\n\n\nThe Scala debugger API provides a simple way to create watchpoints in your\ndebugger application. Given a \nScalaVirtualMachine\n instance, you can execute\nthe \nonAccessWatchpoint\n or \nonUnsafeAccessWatchpoint\n method to place a\nwatchpoint that triggers when a field is accessed (read) or\n\nonModificationWatchpoint\n or \nonUnsafeModificationWatchpoint\n method to\nplace a watchpoint that triggers when a field is modified (written).\n\n\nval s: ScalaVirtualMachine = /* some virtual machine */\ns.onUnsafeAccessWatchpoint(\nsome.class.name\n, \nfieldName\n)\n\n\n\n\nYou do not need to worry about creating the same watchpoint over and over\nas these methods cache your request based on the provided arguments.\nSo, you can reference the same watchpoint multiple times.\n\n\nThe difference between safe and unsafe operations is that the unsafe operation\nwill throw an exception if an error occurs that prevents the watchpoint from\nbeing created while the safe operation will wrap the error in a \nTry\n object.\n\n\nPipelining\n\n\nOnce you have created a watchpoint, you can chain together a pipeline of\nfunctions that you want to execute when the watchpoint is triggered. These\nfunctions are consistent with standard Scala \nmap\n, \nflatMap\n, and \nforeach\n\nstructure.\n\n\nval s: ScalaVirtualMachine = /* some virtual machine */\ns.onUnsafeAccessWatchpoint(\nsome.class.name\n, \nfieldName\n).foreach(e =\n {\n  val className = e.field().declaringType().name()\n  val fieldName = e.field().name()\n\n  println(s\n$className had field $fieldName accessed!\n)\n})\n\n\n\n\nRemoving\n\n\nWhenever you are finished with the watchpoint, you can remove it by closing the\nassociated pipeline.\n\n\nval s: ScalaVirtualMachine = /* some virtual machine */\nval w = s.onUnsafeAccessWatchpoint(\nsome.class.name\n, \nfieldName\n)\n\nw.foreach(_ =\n println(\nField accessed!\n))\n\nimport org.scaladebugger.api.profiles.Constants.CloseRemoveAll\nw.close(data = CloseRemoveAll)\n\n\n\n\n\n\nWarning:\n\n\nCurrently, you must provide close with the flag \nCloseRemoveAll\n in order\nto remove the request and any underlying event handlers.\n\n\nSpecifying close without that flag will only stop events going through\nthat specific pipeline. If all pipelines associated with a request are\nclosed, the request will also be removed.\n\n\n\n\nBy default, \nclose\n will be triggered immediately. Alternatively, you can\ninvoke \nclose\n with \nnow = false\n to close the pipeline once the next\nevent occurs.\n\n\nCookbook\n\n\nSee the \ncookbook\n for a working example.", 
            "title": "Watching class variables"
        }, 
        {
            "location": "/getting-started/watching-class-variables/#working-with-watchpoints", 
            "text": "", 
            "title": "Working with watchpoints"
        }, 
        {
            "location": "/getting-started/watching-class-variables/#overview", 
            "text": "The following will provide you with a brief overview of creating watchpoints,\nchaining together reactions to watchpoint events, and removing watchpoints.", 
            "title": "Overview"
        }, 
        {
            "location": "/getting-started/watching-class-variables/#creating", 
            "text": "The Scala debugger API provides a simple way to create watchpoints in your\ndebugger application. Given a  ScalaVirtualMachine  instance, you can execute\nthe  onAccessWatchpoint  or  onUnsafeAccessWatchpoint  method to place a\nwatchpoint that triggers when a field is accessed (read) or onModificationWatchpoint  or  onUnsafeModificationWatchpoint  method to\nplace a watchpoint that triggers when a field is modified (written).  val s: ScalaVirtualMachine = /* some virtual machine */\ns.onUnsafeAccessWatchpoint( some.class.name ,  fieldName )  You do not need to worry about creating the same watchpoint over and over\nas these methods cache your request based on the provided arguments.\nSo, you can reference the same watchpoint multiple times.  The difference between safe and unsafe operations is that the unsafe operation\nwill throw an exception if an error occurs that prevents the watchpoint from\nbeing created while the safe operation will wrap the error in a  Try  object.", 
            "title": "Creating"
        }, 
        {
            "location": "/getting-started/watching-class-variables/#pipelining", 
            "text": "Once you have created a watchpoint, you can chain together a pipeline of\nfunctions that you want to execute when the watchpoint is triggered. These\nfunctions are consistent with standard Scala  map ,  flatMap , and  foreach \nstructure.  val s: ScalaVirtualMachine = /* some virtual machine */\ns.onUnsafeAccessWatchpoint( some.class.name ,  fieldName ).foreach(e =  {\n  val className = e.field().declaringType().name()\n  val fieldName = e.field().name()\n\n  println(s $className had field $fieldName accessed! )\n})", 
            "title": "Pipelining"
        }, 
        {
            "location": "/getting-started/watching-class-variables/#removing", 
            "text": "Whenever you are finished with the watchpoint, you can remove it by closing the\nassociated pipeline.  val s: ScalaVirtualMachine = /* some virtual machine */\nval w = s.onUnsafeAccessWatchpoint( some.class.name ,  fieldName )\n\nw.foreach(_ =  println( Field accessed! ))\n\nimport org.scaladebugger.api.profiles.Constants.CloseRemoveAll\nw.close(data = CloseRemoveAll)   Warning:  Currently, you must provide close with the flag  CloseRemoveAll  in order\nto remove the request and any underlying event handlers.  Specifying close without that flag will only stop events going through\nthat specific pipeline. If all pipelines associated with a request are\nclosed, the request will also be removed.   By default,  close  will be triggered immediately. Alternatively, you can\ninvoke  close  with  now = false  to close the pipeline once the next\nevent occurs.", 
            "title": "Removing"
        }, 
        {
            "location": "/getting-started/watching-class-variables/#cookbook", 
            "text": "See the  cookbook  for a working example.", 
            "title": "Cookbook"
        }, 
        {
            "location": "/advanced-topics/what-is-the-profile-system/", 
            "text": "What is the Profile System?\n\n\n\n\nOverview\n\n\nThe profile system in the Scala debugger API's way of distinguishing specific\nlogic to handle breakpoints, steps, and other requests in Scala 2.10, Scala\n2.11, Scala 2.12, the Scala REPL, Java, and other scenarios.\n\n\nCurrently, there are no specific profiles for Scala versions. Future plans\ninclude adding logic to better handle closures in Scala 2.10, 2.11, etc.\n\n\nAvailable Functionality\n\n\nThe \nDebugProfile\n trait provides a collection of higher-level methods that\ncan be used to create \nJDI\n requests and process incoming events using the\n\nPipeline\n construct. Each profile implements the \nDebugProfile\n trait.\n\n\nBreakpoints\n\n\n\n\n\n\n\n\nMethod\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nonBreakpoint\n\n\nAttempts to create a breakpoint with the provided file and line number, returning a Try containing a pipeline of breakpoint events.\n\n\n\n\n\n\nonBreakpointWithData\n\n\nAttempts to create a breakpoint with the provided file and line number, returning a Try containing a pipeline of tuples in the form of (event, collection of data) where the data is collected based on provided extra arguments.\n\n\n\n\n\n\nonUnsafeBreakpoint\n\n\nSame as \nonBreakpoint\n, but throws an exception if an error occurs.\n\n\n\n\n\n\nonUnsafeBreakpointWithData\n\n\nSame as \nonBreakpointWithData\n, but throws an exception if an error occurs.\n\n\n\n\n\n\n\n\nClasses\n\n\nClass Loading\n\n\n\n\n\n\n\n\nMethod\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nonClassPrepare\n\n\nAttempts to create a class prepare request (to receive an event whenever a class is loaded into the target JVM), returning a Try containing a pipeline of class prepare events.\n\n\n\n\n\n\nonClassPrepareWithData\n\n\nAttempts to create a class prepare request, returning a Try containing a pipeline of tuples in the form of (event, collection of data) where the data is collected based on provided extra arguments.\n\n\n\n\n\n\nonUnsafeClassPrepare\n\n\nSame as \nonClassPrepare\n, but throws an exception if an error occurs.\n\n\n\n\n\n\nonUnsafeClassPrepareWithData\n\n\nSame as \nonClassPrepareWithData\n, but throws an exception if an error occurs.\n\n\n\n\n\n\n\n\n\n\nNote:\n\n\nThe standard \nScalaVirtualMachine\n already creates this request \nwithout\n\nany extra arguments; so, use of \nonClassPrepare\n will already be cached.\n\n\n\n\nClass Unloading\n\n\n\n\n\n\n\n\nMethod\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nonClassUnload\n\n\nAttempts to create a class unload request (to receive an event whenever a class is unloaded from the target JVM), returning a Try containing a pipeline of class unload events.\n\n\n\n\n\n\nonClassUnloadWithData\n\n\nAttempts to create a class unload request, returning a Try containing a pipeline of tuples in the form of (event, collection of data) where the data is collected based on provided extra arguments.\n\n\n\n\n\n\nonUnsafeClassUnload\n\n\nSame as \nonClassUnload\n, but throws an exception if an error occurs.\n\n\n\n\n\n\nonUnsafeClassUnloadWithData\n\n\nSame as \nonClassUnloadWithData\n, but throws an exception if an error occurs.\n\n\n\n\n\n\n\n\nEvent-only Listening\n\n\n\n\n\n\n\n\nMethod\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nonEvent\n\n\nAttempts to create a resuming event handler for the specified event type that feeds a pipeline of events for the specified event type.\n\n\n\n\n\n\nonEventWithData\n\n\nAttempts to create an event handler, returning a Try containing a pipeline of tuples in the form of (event, collection of data) where the data is collected based on provided extra arguments.\n\n\n\n\n\n\nonUnsafeEvent\n\n\nSame as \nonEvent\n, but throws an exception if an error occurs.\n\n\n\n\n\n\nonUnsafeEventWithData\n\n\nSame as \nonEventWithData\n, but throws an exception if an error occurs.\n\n\n\n\n\n\n\n\n\n\nWarning:\n\n\nThere is currently no caching of event handler creation; so, each call to\n\nonEvent\n or its associated functions will create a new underlying event\nhandler.\n\n\n\n\nExceptions\n\n\nSpecific Exceptions\n\n\n\n\n\n\n\n\nMethod\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nonException\n\n\nAttempts to create a exception request (to receive an event whenever the specified exception or subclass is thrown), returning a Try containing a pipeline of exception events.\n\n\n\n\n\n\nonExceptionWithData\n\n\nAttempts to create a exception request, returning a Try containing a pipeline of tuples in the form of (event, collection of data) where the data is collected based on provided extra arguments.\n\n\n\n\n\n\nonUnsafeException\n\n\nSame as \nonException\n, but throws an exception if an error occurs.\n\n\n\n\n\n\nonUnsafeExceptionWithData\n\n\nSame as \nonExceptionWithData\n, but throws an exception if an error occurs.\n\n\n\n\n\n\n\n\nAll Exceptions\n\n\n\n\n\n\n\n\nMethod\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nonAllExceptions\n\n\nAttempts to create a exception request (to receive an event whenever any exception is thrown), returning a Try containing a pipeline of exception events.\n\n\n\n\n\n\nonAllExceptionsWithData\n\n\nAttempts to create a exception request, returning a Try containing a pipeline of tuples in the form of (event, collection of data) where the data is collected based on provided extra arguments.\n\n\n\n\n\n\nonUnsafeAllExceptions\n\n\nSame as \nonAllExceptions\n, but throws an exception if an error occurs.\n\n\n\n\n\n\nonUnsafeAllExceptionsWithData\n\n\nSame as \nonAllExceptionsWithData\n, but throws an exception if an error occurs.\n\n\n\n\n\n\n\n\nInfo\n\n\n\n\n\n\n\n\nMethod\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\navailableLinesForFile\n\n\nRetrieves the line numbers that are breakpointable in the target JVM for the specified file.\n\n\n\n\n\n\nmainClassName\n\n\nRetrieves the name of the class that served as the entrypoint for the target JVM.\n\n\n\n\n\n\ncommandLineArguments\n\n\nRetrieves the collection of arguments provided to the target JVM at startup.\n\n\n\n\n\n\n\n\nMethods\n\n\nMethod Entry\n\n\n\n\n\n\n\n\nMethod\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nonMethodEntry\n\n\nAttempts to create a method entry request using the provided class and method name, returning a Try containing a pipeline of method entry events.\n\n\n\n\n\n\nonMethodEntryWithData\n\n\nAttempts to create a method entry request, returning a Try containing a pipeline of tuples in the form of (event, collection of data) where the data is collected based on provided extra arguments.\n\n\n\n\n\n\nonUnsafeMethodEntry\n\n\nSame as \nonMethodEntry\n, but throws an exception if an error occurs.\n\n\n\n\n\n\nonUnsafeMethodEntryWithData\n\n\nSame as \nonMethodEntryWithData\n, but throws an exception if an error occurs.\n\n\n\n\n\n\n\n\nMethod Exit\n\n\n\n\n\n\n\n\nMethod\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nonMethodExit\n\n\nAttempts to create a method exit request using the provided class and method name, returning a Try containing a pipeline of method exit events.\n\n\n\n\n\n\nonMethodExitWithData\n\n\nAttempts to create a method exit request, returning a Try containing a pipeline of tuples in the form of (event, collection of data) where the data is collected based on provided extra arguments.\n\n\n\n\n\n\nonUnsafeMethodExit\n\n\nSame as \nonMethodExit\n, but throws an exception if an error occurs.\n\n\n\n\n\n\nonUnsafeMethodExitWithData\n\n\nSame as \nonMethodExitWithData\n, but throws an exception if an error occurs.\n\n\n\n\n\n\n\n\nMonitors\n\n\nMonitor Contended Entered\n\n\n\n\n\n\n\n\nMethod\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nonMonitorContendedEntered\n\n\nAttempts to create a monitor contended entered request, returning a Try containing a pipeline of monitor contended entered events.\n\n\n\n\n\n\nonMonitorContendedEnteredWithData\n\n\nAttempts to create a monitor contended entered request, returning a Try containing a pipeline of tuples in the form of (event, collection of data) where the data is collected based on provided extra arguments.\n\n\n\n\n\n\nonUnsafeMonitorContendedEntered\n\n\nSame as \nonMonitorContendedEntered\n, but throws an exception if an error occurs.\n\n\n\n\n\n\nonUnsafeMonitorContendedEnteredWithData\n\n\nSame as \nonMonitorContendedEnteredWithData\n, but throws an exception if an error occurs.\n\n\n\n\n\n\n\n\nMonitor Contended Enter\n\n\n\n\n\n\n\n\nMethod\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nonMonitorContendedEnter\n\n\nAttempts to create a monitor contended enter request, returning a Try containing a pipeline of monitor contended enter events.\n\n\n\n\n\n\nonMonitorContendedEnterWithData\n\n\nAttempts to create a monitor contended enter request, returning a Try containing a pipeline of tuples in the form of (event, collection of data) where the data is collected based on provided extra arguments.\n\n\n\n\n\n\nonUnsafeMonitorContendedEnter\n\n\nSame as \nonMonitorContendedEnter\n, but throws an exception if an error occurs.\n\n\n\n\n\n\nonUnsafeMonitorContendedEnterWithData\n\n\nSame as \nonMonitorContendedEnterWithData\n, but throws an exception if an error occurs.\n\n\n\n\n\n\n\n\nMonitor Waited\n\n\n\n\n\n\n\n\nMethod\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nonMonitorWaited\n\n\nAttempts to create a monitor waited request, returning a Try containing a pipeline of monitor waited events.\n\n\n\n\n\n\nonMonitorWaitedWithData\n\n\nAttempts to create a monitor waited request, returning a Try containing a pipeline of tuples in the form of (event, collection of data) where the data is collected based on provided extra arguments.\n\n\n\n\n\n\nonUnsafeMonitorWaited\n\n\nSame as \nonMonitorWaited\n, but throws an exception if an error occurs.\n\n\n\n\n\n\nonUnsafeMonitorWaitedWithData\n\n\nSame as \nonMonitorWaitedWithData\n, but throws an exception if an error occurs.\n\n\n\n\n\n\n\n\nMonitor Wait\n\n\n\n\n\n\n\n\nMethod\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nonMonitorWait\n\n\nAttempts to create a monitor wait request, returning a Try containing a pipeline of monitor wait events.\n\n\n\n\n\n\nonMonitorWaitWithData\n\n\nAttempts to create a monitor wait request, returning a Try containing a pipeline of tuples in the form of (event, collection of data) where the data is collected based on provided extra arguments.\n\n\n\n\n\n\nonUnsafeMonitorWait\n\n\nSame as \nonMonitorWait\n, but throws an exception if an error occurs.\n\n\n\n\n\n\nonUnsafeMonitorWaitWithData\n\n\nSame as \nonMonitorWaitWithData\n, but throws an exception if an error occurs.\n\n\n\n\n\n\n\n\nSteps\n\n\nLine-specific steps\n\n\n\n\n\n\n\n\nMethod\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nstepIntoLine\n\n\nAttempts to create a step request to step into the next line of code, returning a future with the result.\n\n\n\n\n\n\nstepIntoLineWithData\n\n\nAttempts to create a step request to step into the next line of code, returning a future with a tuple of (event, collection of data) where data is collected based on provided extra arguments.\n\n\n\n\n\n\nstepOverLine\n\n\nAttempts to create a step request to step over the next line of code, returning a future with the result.\n\n\n\n\n\n\nstepOverLineWithData\n\n\nAttempts to create a step request to step over the next line of code, returning a future with a tuple of (event, collection of data) where data is collected based on provided extra arguments.\n\n\n\n\n\n\nstepOutLine\n\n\nAttempts to create a step request to step out of the next line of code, returning a future with the result.\n\n\n\n\n\n\nstepOutLineWithData\n\n\nAttempts to create a step request to step out of the next line of code, returning a future with a tuple of (event, collection of data) where data is collected based on provided extra arguments.\n\n\n\n\n\n\n\n\nNext available location steps\n\n\n\n\n\n\n\n\nMethod\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nstepIntoMin\n\n\nAttempts to create a step request to step into the next location, returning a future with the result.\n\n\n\n\n\n\nstepIntoMinWithData\n\n\nAttempts to create a step request to step into the next location, returning a future with a tuple of (event, collection of data) where data is collected based on provided extra arguments.\n\n\n\n\n\n\nstepOverMin\n\n\nAttempts to create a step request to step over the next location, returning a future with the result.\n\n\n\n\n\n\nstepOverMinWithData\n\n\nAttempts to create a step request to step over the next location, returning a future with a tuple of (event, collection of data) where data is collected based on provided extra arguments.\n\n\n\n\n\n\nstepOutMin\n\n\nAttempts to create a step request to step out of the next location, returning a future with the result.\n\n\n\n\n\n\nstepOutMinWithData\n\n\nAttempts to create a step request to step out of the next location, returning a future with a tuple of (event, collection of data) where data is collected based on provided extra arguments.\n\n\n\n\n\n\n\n\nEvent-only listening\n\n\n\n\n\n\n\n\nMethod\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nonStep\n\n\nAttempts to create a resuming event handler for the step events that feeds a pipeline of step events.\n\n\n\n\n\n\nonStepWithData\n\n\nAttempts to create a resumingevent handler for step events, returning a Try containing a pipeline of tuples in the form of (event, collection of data) where the data is collected based on provided extra arguments.\n\n\n\n\n\n\nonUnsafeStep\n\n\nSame as \nonStep\n, but throws an exception if an error occurs.\n\n\n\n\n\n\nonUnsafeStepWithData\n\n\nSame as \nonStepWithData\n, but throws an exception if an error occurs.\n\n\n\n\n\n\n\n\n\n\nWarning:\n\n\nThere is currently no caching of event handler creation; so, each call to\n\nonStep\n or its associated functions will create a new underlying event\nhandler.\n\n\n\n\nThreads\n\n\nThread Death\n\n\n\n\n\n\n\n\nMethod\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nonThreadDeath\n\n\nAttempts to create a thread death request, returning a Try containing a pipeline of thread death events.\n\n\n\n\n\n\nonThreadDeathWithData\n\n\nAttempts to create a thread death request, returning a Try containing a pipeline of tuples in the form of (event, collection of data) where the data is collected based on provided extra arguments.\n\n\n\n\n\n\nonUnsafeThreadDeath\n\n\nSame as \nonThreadDeath\n, but throws an exception if an error occurs.\n\n\n\n\n\n\nonUnsafeThreadDeathWithData\n\n\nSame as \nonThreadDeathWithData\n, but throws an exception if an error occurs.\n\n\n\n\n\n\n\n\nThread Start\n\n\n\n\n\n\n\n\nMethod\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nonThreadStart\n\n\nAttempts to create a thread start request, returning a Try containing a pipeline of thread start events.\n\n\n\n\n\n\nonThreadStartWithData\n\n\nAttempts to create a thread start request, returning a Try containing a pipeline of tuples in the form of (event, collection of data) where the data is collected based on provided extra arguments.\n\n\n\n\n\n\nonUnsafeThreadStart\n\n\nSame as \nonThreadStart\n, but throws an exception if an error occurs.\n\n\n\n\n\n\nonUnsafeThreadStartWithData\n\n\nSame as \nonThreadStartWithData\n, but throws an exception if an error occurs.\n\n\n\n\n\n\n\n\nVirtual Machine Status\n\n\nVM Start\n\n\n\n\n\n\n\n\nMethod\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nonVMStart\n\n\nAttempts to create an event handler for vm start events, returning a Try containing a pipeline of vm start events.\n\n\n\n\n\n\nonVMStartWithData\n\n\nAttempts to create an event handler for vm start events, returning a Try containing a pipeline of tuples in the form of (event, collection of data) where the data is collected based on provided extra arguments.\n\n\n\n\n\n\nonUnsafeVMStart\n\n\nSame as \nonVMStart\n, but throws an exception if an error occurs.\n\n\n\n\n\n\nonUnsafeVMStartWithData\n\n\nSame as \nonVMStartWithData\n, but throws an exception if an error occurs.\n\n\n\n\n\n\n\n\nVM Disconnect\n\n\n\n\n\n\n\n\nMethod\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nonVMDisconnect\n\n\nAttempts to create an event handler for vm disconnect events, returning a Try containing a pipeline of vm disconnect events.\n\n\n\n\n\n\nonVMDisconnectWithData\n\n\nAttempts to create an event handler for vm disconnect events, returning a Try containing a pipeline of tuples in the form of (event, collection of data) where the data is collected based on provided extra arguments.\n\n\n\n\n\n\nonUnsafeVMDisconnect\n\n\nSame as \nonVMDisconnect\n, but throws an exception if an error occurs.\n\n\n\n\n\n\nonUnsafeVMDisconnectWithData\n\n\nSame as \nonVMDisconnectWithData\n, but throws an exception if an error occurs.\n\n\n\n\n\n\n\n\nVM Death\n\n\n\n\n\n\n\n\nMethod\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nonVMDeath\n\n\nAttempts to create a vm death request, returning a Try containing a pipeline of vm death events.\n\n\n\n\n\n\nonVMDeathWithData\n\n\nAttempts to create a vm death request, returning a Try containing a pipeline of tuples in the form of (event, collection of data) where the data is collected based on provided extra arguments.\n\n\n\n\n\n\nonUnsafeVMDeath\n\n\nSame as \nonVMDeath\n, but throws an exception if an error occurs.\n\n\n\n\n\n\nonUnsafeVMDeathWithData\n\n\nSame as \nonVMDeathWithData\n, but throws an exception if an error occurs.\n\n\n\n\n\n\n\n\nWatchpoints\n\n\nAccess Watchpoint\n\n\n\n\n\n\n\n\nMethod\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nonAccessWatchpoint\n\n\nAttempts to create a access watchpoint request for the specified class' field, returning a Try containing a pipeline of access watchpoint events.\n\n\n\n\n\n\nonAccessWatchpointWithData\n\n\nAttempts to create a access watchpoint request for the specified class' field, returning a Try containing a pipeline of tuples in the form of (event, collection of data) where the data is collected based on provided extra arguments.\n\n\n\n\n\n\nonUnsafeAccessWatchpoint\n\n\nSame as \nonAccessWatchpoint\n, but throws an exception if an error occurs.\n\n\n\n\n\n\nonUnsafeAccessWatchpointWithData\n\n\nSame as \nonAccessWatchpointWithData\n, but throws an exception if an error occurs.\n\n\n\n\n\n\n\n\nModification Watchpoint\n\n\n\n\n\n\n\n\nMethod\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nonModificationWatchpoint\n\n\nAttempts to create a modification watchpoint request for the specified class' field, returning a Try containing a pipeline of modification watchpoint events.\n\n\n\n\n\n\nonModificationWatchpointWithData\n\n\nAttempts to create a modification watchpoint request for the specified class' field, returning a Try containing a pipeline of tuples in the form of (event, collection of data) where the data is collected based on provided extra arguments.\n\n\n\n\n\n\nonUnsafeModificationWatchpoint\n\n\nSame as \nonModificationWatchpoint\n, but throws an exception if an error occurs.\n\n\n\n\n\n\nonUnsafeModificationWatchpointWithData\n\n\nSame as \nonModificationWatchpointWithData\n, but throws an exception if an error occurs.\n\n\n\n\n\n\n\n\nPure Profile\n\n\nThe pure profile is the default profile for the \nScalaVirtualMachine\n. It adds\nno custom logic for any of the Scala versions; therefore, it should be able to\nwork with Java code.\n\n\nThe pure profile adds support for caching requests, which means calls to\n\nonBreakpoint\n, \nonUnsafeBreakpoint\n, etc. with the same arguments will use the\nsame \nJDI\n request underneath. This allows you to refer to the breakpoint in a\nmore flowing manner like the following:\n\n\nval s: ScalaVirtualMachine = /* some virtual machine */\n\n// Creates the breakpoint request for the first time, creates a pipeline to\n// receive breakpoint events\ns.onBreakpoint(\nmyfile.scala\n, 37)\n  .map(_.location().lineNumber())\n  .foreach(l =\n println(s\nReached line number $l\n))\n\n// Reuses the same breakpoint request, creates a pipeline to receive\n// breakpoint events\ns.onBreakpoint(\nmyfile.scala\n, 37)\n  .map(_.location().sourcePath())\n  .foreach(p =\n println(s\nBreakpoint occurred in $p\n))\n\n\n\n\nYou can specifically reference the profile using its name:\n\n\nval s: ScalaVirtualMachine = /* some virtual machine */\n\n// Use the ScalaVirtualMachine with the pure profile\nimport org.scaladebugger.api.profiles.pure.PureDebugProfile\ns.withProfile(PureDebugProfile.Name).onBreakpoint(\nmyfile.scala\n, 37)\n\n\n\n\nSwappable Profile\n\n\nThe swappable profile is a different profile abstraction. Rather than\nproviding specific debugger logic, this profile allows you to change which\nprofile you are using automatically. The \nScalaVirtualMachine\n class inherits\nfrom the \nSwappableDebugProfile\n trait, which is why \nScalaVirtualMachine\n can\nchange between different profiles.\n\n\n\n\n\n\n\n\nMethod\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nuse\n\n\nChanges the current profile to the specified profile.\n\n\n\n\n\n\nwithCurrentProfile\n\n\nReturns the current underlying profile.\n\n\n\n\n\n\nwithProfile\n\n\nReturns the profile with the specified name.\n\n\n\n\n\n\n\n\n// Inherits the SwappableDebugProfile trait\nval s: ScalaVirtualMachine = /* some virtual machine */\n\n// All future calls to the profile will route to the pure debug profile\ns.use(PureDebugProfile.Name)\n\n// This will be handled by the pure debug profile\ns.onBreakpoint(\nfile.scala\n, 37)\n\n\n\n\nAdding your own profile\n\n\nWhile default profiles are available in the \nScalaVirtualMachine\n by default,\nthere may be times where you want/need to provide your own profile. This can be\ndone by invoking the \nregister\n function on the \nScalaVirtualMachine\n class.\n\n\n// Inherits the ProfileManager trait\nval s: ScalaVirtualMachine = /* some virtual machine */\n\ns.register(\nprofile name\n, /* profile instance */)", 
            "title": "What is the Profile System?"
        }, 
        {
            "location": "/advanced-topics/what-is-the-profile-system/#what-is-the-profile-system", 
            "text": "", 
            "title": "What is the Profile System?"
        }, 
        {
            "location": "/advanced-topics/what-is-the-profile-system/#overview", 
            "text": "The profile system in the Scala debugger API's way of distinguishing specific\nlogic to handle breakpoints, steps, and other requests in Scala 2.10, Scala\n2.11, Scala 2.12, the Scala REPL, Java, and other scenarios.  Currently, there are no specific profiles for Scala versions. Future plans\ninclude adding logic to better handle closures in Scala 2.10, 2.11, etc.", 
            "title": "Overview"
        }, 
        {
            "location": "/advanced-topics/what-is-the-profile-system/#available-functionality", 
            "text": "The  DebugProfile  trait provides a collection of higher-level methods that\ncan be used to create  JDI  requests and process incoming events using the Pipeline  construct. Each profile implements the  DebugProfile  trait.  Breakpoints     Method  Description      onBreakpoint  Attempts to create a breakpoint with the provided file and line number, returning a Try containing a pipeline of breakpoint events.    onBreakpointWithData  Attempts to create a breakpoint with the provided file and line number, returning a Try containing a pipeline of tuples in the form of (event, collection of data) where the data is collected based on provided extra arguments.    onUnsafeBreakpoint  Same as  onBreakpoint , but throws an exception if an error occurs.    onUnsafeBreakpointWithData  Same as  onBreakpointWithData , but throws an exception if an error occurs.     Classes  Class Loading     Method  Description      onClassPrepare  Attempts to create a class prepare request (to receive an event whenever a class is loaded into the target JVM), returning a Try containing a pipeline of class prepare events.    onClassPrepareWithData  Attempts to create a class prepare request, returning a Try containing a pipeline of tuples in the form of (event, collection of data) where the data is collected based on provided extra arguments.    onUnsafeClassPrepare  Same as  onClassPrepare , but throws an exception if an error occurs.    onUnsafeClassPrepareWithData  Same as  onClassPrepareWithData , but throws an exception if an error occurs.      Note:  The standard  ScalaVirtualMachine  already creates this request  without \nany extra arguments; so, use of  onClassPrepare  will already be cached.   Class Unloading     Method  Description      onClassUnload  Attempts to create a class unload request (to receive an event whenever a class is unloaded from the target JVM), returning a Try containing a pipeline of class unload events.    onClassUnloadWithData  Attempts to create a class unload request, returning a Try containing a pipeline of tuples in the form of (event, collection of data) where the data is collected based on provided extra arguments.    onUnsafeClassUnload  Same as  onClassUnload , but throws an exception if an error occurs.    onUnsafeClassUnloadWithData  Same as  onClassUnloadWithData , but throws an exception if an error occurs.     Event-only Listening     Method  Description      onEvent  Attempts to create a resuming event handler for the specified event type that feeds a pipeline of events for the specified event type.    onEventWithData  Attempts to create an event handler, returning a Try containing a pipeline of tuples in the form of (event, collection of data) where the data is collected based on provided extra arguments.    onUnsafeEvent  Same as  onEvent , but throws an exception if an error occurs.    onUnsafeEventWithData  Same as  onEventWithData , but throws an exception if an error occurs.      Warning:  There is currently no caching of event handler creation; so, each call to onEvent  or its associated functions will create a new underlying event\nhandler.   Exceptions  Specific Exceptions     Method  Description      onException  Attempts to create a exception request (to receive an event whenever the specified exception or subclass is thrown), returning a Try containing a pipeline of exception events.    onExceptionWithData  Attempts to create a exception request, returning a Try containing a pipeline of tuples in the form of (event, collection of data) where the data is collected based on provided extra arguments.    onUnsafeException  Same as  onException , but throws an exception if an error occurs.    onUnsafeExceptionWithData  Same as  onExceptionWithData , but throws an exception if an error occurs.     All Exceptions     Method  Description      onAllExceptions  Attempts to create a exception request (to receive an event whenever any exception is thrown), returning a Try containing a pipeline of exception events.    onAllExceptionsWithData  Attempts to create a exception request, returning a Try containing a pipeline of tuples in the form of (event, collection of data) where the data is collected based on provided extra arguments.    onUnsafeAllExceptions  Same as  onAllExceptions , but throws an exception if an error occurs.    onUnsafeAllExceptionsWithData  Same as  onAllExceptionsWithData , but throws an exception if an error occurs.     Info     Method  Description      availableLinesForFile  Retrieves the line numbers that are breakpointable in the target JVM for the specified file.    mainClassName  Retrieves the name of the class that served as the entrypoint for the target JVM.    commandLineArguments  Retrieves the collection of arguments provided to the target JVM at startup.     Methods  Method Entry     Method  Description      onMethodEntry  Attempts to create a method entry request using the provided class and method name, returning a Try containing a pipeline of method entry events.    onMethodEntryWithData  Attempts to create a method entry request, returning a Try containing a pipeline of tuples in the form of (event, collection of data) where the data is collected based on provided extra arguments.    onUnsafeMethodEntry  Same as  onMethodEntry , but throws an exception if an error occurs.    onUnsafeMethodEntryWithData  Same as  onMethodEntryWithData , but throws an exception if an error occurs.     Method Exit     Method  Description      onMethodExit  Attempts to create a method exit request using the provided class and method name, returning a Try containing a pipeline of method exit events.    onMethodExitWithData  Attempts to create a method exit request, returning a Try containing a pipeline of tuples in the form of (event, collection of data) where the data is collected based on provided extra arguments.    onUnsafeMethodExit  Same as  onMethodExit , but throws an exception if an error occurs.    onUnsafeMethodExitWithData  Same as  onMethodExitWithData , but throws an exception if an error occurs.     Monitors  Monitor Contended Entered     Method  Description      onMonitorContendedEntered  Attempts to create a monitor contended entered request, returning a Try containing a pipeline of monitor contended entered events.    onMonitorContendedEnteredWithData  Attempts to create a monitor contended entered request, returning a Try containing a pipeline of tuples in the form of (event, collection of data) where the data is collected based on provided extra arguments.    onUnsafeMonitorContendedEntered  Same as  onMonitorContendedEntered , but throws an exception if an error occurs.    onUnsafeMonitorContendedEnteredWithData  Same as  onMonitorContendedEnteredWithData , but throws an exception if an error occurs.     Monitor Contended Enter     Method  Description      onMonitorContendedEnter  Attempts to create a monitor contended enter request, returning a Try containing a pipeline of monitor contended enter events.    onMonitorContendedEnterWithData  Attempts to create a monitor contended enter request, returning a Try containing a pipeline of tuples in the form of (event, collection of data) where the data is collected based on provided extra arguments.    onUnsafeMonitorContendedEnter  Same as  onMonitorContendedEnter , but throws an exception if an error occurs.    onUnsafeMonitorContendedEnterWithData  Same as  onMonitorContendedEnterWithData , but throws an exception if an error occurs.     Monitor Waited     Method  Description      onMonitorWaited  Attempts to create a monitor waited request, returning a Try containing a pipeline of monitor waited events.    onMonitorWaitedWithData  Attempts to create a monitor waited request, returning a Try containing a pipeline of tuples in the form of (event, collection of data) where the data is collected based on provided extra arguments.    onUnsafeMonitorWaited  Same as  onMonitorWaited , but throws an exception if an error occurs.    onUnsafeMonitorWaitedWithData  Same as  onMonitorWaitedWithData , but throws an exception if an error occurs.     Monitor Wait     Method  Description      onMonitorWait  Attempts to create a monitor wait request, returning a Try containing a pipeline of monitor wait events.    onMonitorWaitWithData  Attempts to create a monitor wait request, returning a Try containing a pipeline of tuples in the form of (event, collection of data) where the data is collected based on provided extra arguments.    onUnsafeMonitorWait  Same as  onMonitorWait , but throws an exception if an error occurs.    onUnsafeMonitorWaitWithData  Same as  onMonitorWaitWithData , but throws an exception if an error occurs.     Steps  Line-specific steps     Method  Description      stepIntoLine  Attempts to create a step request to step into the next line of code, returning a future with the result.    stepIntoLineWithData  Attempts to create a step request to step into the next line of code, returning a future with a tuple of (event, collection of data) where data is collected based on provided extra arguments.    stepOverLine  Attempts to create a step request to step over the next line of code, returning a future with the result.    stepOverLineWithData  Attempts to create a step request to step over the next line of code, returning a future with a tuple of (event, collection of data) where data is collected based on provided extra arguments.    stepOutLine  Attempts to create a step request to step out of the next line of code, returning a future with the result.    stepOutLineWithData  Attempts to create a step request to step out of the next line of code, returning a future with a tuple of (event, collection of data) where data is collected based on provided extra arguments.     Next available location steps     Method  Description      stepIntoMin  Attempts to create a step request to step into the next location, returning a future with the result.    stepIntoMinWithData  Attempts to create a step request to step into the next location, returning a future with a tuple of (event, collection of data) where data is collected based on provided extra arguments.    stepOverMin  Attempts to create a step request to step over the next location, returning a future with the result.    stepOverMinWithData  Attempts to create a step request to step over the next location, returning a future with a tuple of (event, collection of data) where data is collected based on provided extra arguments.    stepOutMin  Attempts to create a step request to step out of the next location, returning a future with the result.    stepOutMinWithData  Attempts to create a step request to step out of the next location, returning a future with a tuple of (event, collection of data) where data is collected based on provided extra arguments.     Event-only listening     Method  Description      onStep  Attempts to create a resuming event handler for the step events that feeds a pipeline of step events.    onStepWithData  Attempts to create a resumingevent handler for step events, returning a Try containing a pipeline of tuples in the form of (event, collection of data) where the data is collected based on provided extra arguments.    onUnsafeStep  Same as  onStep , but throws an exception if an error occurs.    onUnsafeStepWithData  Same as  onStepWithData , but throws an exception if an error occurs.      Warning:  There is currently no caching of event handler creation; so, each call to onStep  or its associated functions will create a new underlying event\nhandler.   Threads  Thread Death     Method  Description      onThreadDeath  Attempts to create a thread death request, returning a Try containing a pipeline of thread death events.    onThreadDeathWithData  Attempts to create a thread death request, returning a Try containing a pipeline of tuples in the form of (event, collection of data) where the data is collected based on provided extra arguments.    onUnsafeThreadDeath  Same as  onThreadDeath , but throws an exception if an error occurs.    onUnsafeThreadDeathWithData  Same as  onThreadDeathWithData , but throws an exception if an error occurs.     Thread Start     Method  Description      onThreadStart  Attempts to create a thread start request, returning a Try containing a pipeline of thread start events.    onThreadStartWithData  Attempts to create a thread start request, returning a Try containing a pipeline of tuples in the form of (event, collection of data) where the data is collected based on provided extra arguments.    onUnsafeThreadStart  Same as  onThreadStart , but throws an exception if an error occurs.    onUnsafeThreadStartWithData  Same as  onThreadStartWithData , but throws an exception if an error occurs.     Virtual Machine Status  VM Start     Method  Description      onVMStart  Attempts to create an event handler for vm start events, returning a Try containing a pipeline of vm start events.    onVMStartWithData  Attempts to create an event handler for vm start events, returning a Try containing a pipeline of tuples in the form of (event, collection of data) where the data is collected based on provided extra arguments.    onUnsafeVMStart  Same as  onVMStart , but throws an exception if an error occurs.    onUnsafeVMStartWithData  Same as  onVMStartWithData , but throws an exception if an error occurs.     VM Disconnect     Method  Description      onVMDisconnect  Attempts to create an event handler for vm disconnect events, returning a Try containing a pipeline of vm disconnect events.    onVMDisconnectWithData  Attempts to create an event handler for vm disconnect events, returning a Try containing a pipeline of tuples in the form of (event, collection of data) where the data is collected based on provided extra arguments.    onUnsafeVMDisconnect  Same as  onVMDisconnect , but throws an exception if an error occurs.    onUnsafeVMDisconnectWithData  Same as  onVMDisconnectWithData , but throws an exception if an error occurs.     VM Death     Method  Description      onVMDeath  Attempts to create a vm death request, returning a Try containing a pipeline of vm death events.    onVMDeathWithData  Attempts to create a vm death request, returning a Try containing a pipeline of tuples in the form of (event, collection of data) where the data is collected based on provided extra arguments.    onUnsafeVMDeath  Same as  onVMDeath , but throws an exception if an error occurs.    onUnsafeVMDeathWithData  Same as  onVMDeathWithData , but throws an exception if an error occurs.     Watchpoints  Access Watchpoint     Method  Description      onAccessWatchpoint  Attempts to create a access watchpoint request for the specified class' field, returning a Try containing a pipeline of access watchpoint events.    onAccessWatchpointWithData  Attempts to create a access watchpoint request for the specified class' field, returning a Try containing a pipeline of tuples in the form of (event, collection of data) where the data is collected based on provided extra arguments.    onUnsafeAccessWatchpoint  Same as  onAccessWatchpoint , but throws an exception if an error occurs.    onUnsafeAccessWatchpointWithData  Same as  onAccessWatchpointWithData , but throws an exception if an error occurs.     Modification Watchpoint     Method  Description      onModificationWatchpoint  Attempts to create a modification watchpoint request for the specified class' field, returning a Try containing a pipeline of modification watchpoint events.    onModificationWatchpointWithData  Attempts to create a modification watchpoint request for the specified class' field, returning a Try containing a pipeline of tuples in the form of (event, collection of data) where the data is collected based on provided extra arguments.    onUnsafeModificationWatchpoint  Same as  onModificationWatchpoint , but throws an exception if an error occurs.    onUnsafeModificationWatchpointWithData  Same as  onModificationWatchpointWithData , but throws an exception if an error occurs.", 
            "title": "Available Functionality"
        }, 
        {
            "location": "/advanced-topics/what-is-the-profile-system/#pure-profile", 
            "text": "The pure profile is the default profile for the  ScalaVirtualMachine . It adds\nno custom logic for any of the Scala versions; therefore, it should be able to\nwork with Java code.  The pure profile adds support for caching requests, which means calls to onBreakpoint ,  onUnsafeBreakpoint , etc. with the same arguments will use the\nsame  JDI  request underneath. This allows you to refer to the breakpoint in a\nmore flowing manner like the following:  val s: ScalaVirtualMachine = /* some virtual machine */\n\n// Creates the breakpoint request for the first time, creates a pipeline to\n// receive breakpoint events\ns.onBreakpoint( myfile.scala , 37)\n  .map(_.location().lineNumber())\n  .foreach(l =  println(s Reached line number $l ))\n\n// Reuses the same breakpoint request, creates a pipeline to receive\n// breakpoint events\ns.onBreakpoint( myfile.scala , 37)\n  .map(_.location().sourcePath())\n  .foreach(p =  println(s Breakpoint occurred in $p ))  You can specifically reference the profile using its name:  val s: ScalaVirtualMachine = /* some virtual machine */\n\n// Use the ScalaVirtualMachine with the pure profile\nimport org.scaladebugger.api.profiles.pure.PureDebugProfile\ns.withProfile(PureDebugProfile.Name).onBreakpoint( myfile.scala , 37)", 
            "title": "Pure Profile"
        }, 
        {
            "location": "/advanced-topics/what-is-the-profile-system/#swappable-profile", 
            "text": "The swappable profile is a different profile abstraction. Rather than\nproviding specific debugger logic, this profile allows you to change which\nprofile you are using automatically. The  ScalaVirtualMachine  class inherits\nfrom the  SwappableDebugProfile  trait, which is why  ScalaVirtualMachine  can\nchange between different profiles.     Method  Description      use  Changes the current profile to the specified profile.    withCurrentProfile  Returns the current underlying profile.    withProfile  Returns the profile with the specified name.     // Inherits the SwappableDebugProfile trait\nval s: ScalaVirtualMachine = /* some virtual machine */\n\n// All future calls to the profile will route to the pure debug profile\ns.use(PureDebugProfile.Name)\n\n// This will be handled by the pure debug profile\ns.onBreakpoint( file.scala , 37)", 
            "title": "Swappable Profile"
        }, 
        {
            "location": "/advanced-topics/what-is-the-profile-system/#adding-your-own-profile", 
            "text": "While default profiles are available in the  ScalaVirtualMachine  by default,\nthere may be times where you want/need to provide your own profile. This can be\ndone by invoking the  register  function on the  ScalaVirtualMachine  class.  // Inherits the ProfileManager trait\nval s: ScalaVirtualMachine = /* some virtual machine */\n\ns.register( profile name , /* profile instance */)", 
            "title": "Adding your own profile"
        }, 
        {
            "location": "/advanced-topics/what-is-the-low-level-api/", 
            "text": "What is the Low-Level API?\n\n\n\n\nOverview\n\n\nThe low-level API is a light abstraction around the \nJDI\n that manages the\ncreation, retrieval, and removal of requests for breakpoints, watchpoints,\nmonitors, and all other \nEventRequest\n entities.\n\n\nThe API uses the notion of reactive event handlers that are triggered\nwhenever a new event occurs, separating handlers by event type (breakpoint,\nwatchpoint, etc).\n\n\nUsing event handlers\n\n\nEvent handlers are controlled using the \nEventManager\n class. Whenever a\nrequest reports an event, all handlers (functions) for the associated event\ntype are evaluated. Using \naddEventHandler\n will allow you to specify whether\nor not you want the target JVM to resume (if the JVM or thread was suspended\ndue to the request). Using \naddResumingEventHandler\n or \naddEventStream\n will\nresult in the JVM resuming automatically after evaluating your function(s).\n\n\n\n\n\n\n\n\nMethod\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\naddEventStream\n\n\nCreates a new pipeline that is fed all events of a specified type.\n\n\n\n\n\n\naddEventStreamWithId\n\n\nSame as \naddEventStream\n, but with the ability to specify the underlying handler's id.\n\n\n\n\n\n\naddEventDataStream\n\n\nCreates a new pipeline that is fed all events of a specified type and any collected data specified from extra arguments.\n\n\n\n\n\n\naddEventDataStreamWithId\n\n\nSame as \naddEventDataStream\n, but with the ability to specify the underlying handler's id.\n\n\n\n\n\n\naddEventHandler\n\n\nAdds a new function to the list that will be called when events of the specified type are received. If returns false, the target JVM remains suspended.\n\n\n\n\n\n\naddEventHandlerWithId\n\n\nSame as \naddEventHandler\n, but with the ability to specify the id of the event handler.\n\n\n\n\n\n\naddResumingEventHandler\n\n\nSame as \naddEventHandler\n, but the target JVM is always resumed (if the JVM or thread was suspended).\n\n\n\n\n\n\naddResumingEventHandlerWithId\n\n\nSame as \naddEventHandlerWithId\n, but the target JVM is always resumed (if the JVM or thread was suspended).\n\n\n\n\n\n\naddEventHandlerFromInfo\n\n\nAdds the function from the \nEventHandlerInfo\n as a new event handler.\n\n\n\n\n\n\n\n\nExample\n\n\nThe following example demonstrates creating a breakpoint using the low-level\n\nBreakpointManager\n and listening for breakpoint events using the\n\nEventManager\n.\n\n\nval s: ScalaVirtualMachine = /* some virtual machine */\n\n// Create a breakpoint on line 37 of file.scala\n// NOTE: Returns a Try[String] where the string is the id that can be used\n//       to retrieve or remove the request via the low-level manager\ns.lowlevel.breakpointManager.createBreakpointRequest(\nfile.scala\n, 37)\n\n// NOTE: Unlike high-level APIs, the event handler only passes back\n//       generic JDI Event objects that must be cast to the appropriate\n//       event type\neventManager.addResumingEventHandler(BreakpointEventType, e =\n {\n  val breakpointEvent = e.asInstanceOf[BreakpointEvent]\n  val location = breakpointEvent.location()\n  val fileName = location.sourcePath()\n  val lineNumber = location.lineNumber()\n\n  println(s\nReached breakpoint: $fileName:$lineNumber\n)\n})\n\n\n\n\nLearn More\n\n\nPlease see the Scaladocs for more information on using individual managers\nof the low-level API.", 
            "title": "What is the Low-Level API?"
        }, 
        {
            "location": "/advanced-topics/what-is-the-low-level-api/#what-is-the-low-level-api", 
            "text": "", 
            "title": "What is the Low-Level API?"
        }, 
        {
            "location": "/advanced-topics/what-is-the-low-level-api/#overview", 
            "text": "The low-level API is a light abstraction around the  JDI  that manages the\ncreation, retrieval, and removal of requests for breakpoints, watchpoints,\nmonitors, and all other  EventRequest  entities.  The API uses the notion of reactive event handlers that are triggered\nwhenever a new event occurs, separating handlers by event type (breakpoint,\nwatchpoint, etc).", 
            "title": "Overview"
        }, 
        {
            "location": "/advanced-topics/what-is-the-low-level-api/#using-event-handlers", 
            "text": "Event handlers are controlled using the  EventManager  class. Whenever a\nrequest reports an event, all handlers (functions) for the associated event\ntype are evaluated. Using  addEventHandler  will allow you to specify whether\nor not you want the target JVM to resume (if the JVM or thread was suspended\ndue to the request). Using  addResumingEventHandler  or  addEventStream  will\nresult in the JVM resuming automatically after evaluating your function(s).     Method  Description      addEventStream  Creates a new pipeline that is fed all events of a specified type.    addEventStreamWithId  Same as  addEventStream , but with the ability to specify the underlying handler's id.    addEventDataStream  Creates a new pipeline that is fed all events of a specified type and any collected data specified from extra arguments.    addEventDataStreamWithId  Same as  addEventDataStream , but with the ability to specify the underlying handler's id.    addEventHandler  Adds a new function to the list that will be called when events of the specified type are received. If returns false, the target JVM remains suspended.    addEventHandlerWithId  Same as  addEventHandler , but with the ability to specify the id of the event handler.    addResumingEventHandler  Same as  addEventHandler , but the target JVM is always resumed (if the JVM or thread was suspended).    addResumingEventHandlerWithId  Same as  addEventHandlerWithId , but the target JVM is always resumed (if the JVM or thread was suspended).    addEventHandlerFromInfo  Adds the function from the  EventHandlerInfo  as a new event handler.", 
            "title": "Using event handlers"
        }, 
        {
            "location": "/advanced-topics/what-is-the-low-level-api/#example", 
            "text": "The following example demonstrates creating a breakpoint using the low-level BreakpointManager  and listening for breakpoint events using the EventManager .  val s: ScalaVirtualMachine = /* some virtual machine */\n\n// Create a breakpoint on line 37 of file.scala\n// NOTE: Returns a Try[String] where the string is the id that can be used\n//       to retrieve or remove the request via the low-level manager\ns.lowlevel.breakpointManager.createBreakpointRequest( file.scala , 37)\n\n// NOTE: Unlike high-level APIs, the event handler only passes back\n//       generic JDI Event objects that must be cast to the appropriate\n//       event type\neventManager.addResumingEventHandler(BreakpointEventType, e =  {\n  val breakpointEvent = e.asInstanceOf[BreakpointEvent]\n  val location = breakpointEvent.location()\n  val fileName = location.sourcePath()\n  val lineNumber = location.lineNumber()\n\n  println(s Reached breakpoint: $fileName:$lineNumber )\n})", 
            "title": "Example"
        }, 
        {
            "location": "/advanced-topics/what-is-the-low-level-api/#learn-more", 
            "text": "Please see the Scaladocs for more information on using individual managers\nof the low-level API.", 
            "title": "Learn More"
        }, 
        {
            "location": "/advanced-topics/using-extra-arguments-for-requests/", 
            "text": "Using Extra Arguments for Requests\n\n\n\n\nOverview\n\n\nWith both profiles and the low-level API, you are able to provide extra\narguments in the form of \nJDIArgument\n or one of its derivatives:\n\nJDIRequestArgument\n or \nJDIEventArgument\n. The extra arguments are used to\nset additional configuration options on requests as well as provide additional\nfiltering and logic when receiving events.\n\n\nMethods like \nonBreakpoint\n and \ncreateBreakpointRequest\n accept a variable\nnumber of extra arguments at the end of the method (defaulting to no extra\narguments).\n\n\nval s: ScalaVirtualMachine = /* some virtual machine */\n\n// Set a custom property accessible on the request object AND limit reporting\n// to the first three occurrences\ns.onBreakpoint(\nfile.scala\n, 37, CustomProperty(\nkey\n, \nvalue\n), MaxTriggerFilter(3))\n\n\n\n\nRequest Arguments\n\n\nJDIRequestArgument\n instances come in two flavors: \nJDIRequestProperty\n and\n\nJDIRequestFilter\n.\n\n\nProperties are used to configure information about a request such as its\nsuspension level.\n\n\nFilters are used to narrow down what a request reports. In the case of a\nbreakpoint request, you might limit the thread where the breakpoint can\noccur or the specific instance of a class that can trigger the event.\n\n\nRequest Properties\n\n\n\n\n\n\n\n\nCase Class\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nEnabledProperty\n\n\nSets whether or not the request is enabled.\n\n\n\n\n\n\nSuspendPolicyProperty\n\n\nSets the suspend policy of the request.\n\n\n\n\n\n\nCustomProperty\n\n\nAdds a key/value pair to the request that can be referenced when receiving events for that request.\n\n\n\n\n\n\nUniqueIdProperty\n\n\nAdds a unique id to the request via a custom property.\n\n\n\n\n\n\n\n\nRequest Filters\n\n\n\n\n\n\n\n\nCase Class\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nClassExclusionFilter\n\n\nLimits reporting of events to only classes not specified by this filter.\n\n\n\n\n\n\nClassInclusionFilter\n\n\nLimits reporting of events to only classes specified by this filter.\n\n\n\n\n\n\nClassReferenceFilter\n\n\nSimilar to \nClassInclusionFilter\n, but takes a \nJDI\n \nReferenceType\n instead of a string name.\n\n\n\n\n\n\nCountFilter\n\n\nLimits reporting to only occur after N-1 occurrences of the event. Furthermore, the event is only reported once.\n\n\n\n\n\n\nInstanceFilter\n\n\nLimits reporting of events to a specific instance of a class.\n\n\n\n\n\n\nSourceNameFilter\n\n\nLimits reporting of events to classes whose source name matches the specified pattern.\n\n\n\n\n\n\nThreadFilter\n\n\nLimits reporting of events to the specific thread.\n\n\n\n\n\n\n\n\nEvent Arguments\n\n\nJDIEventArgument\n instances come in two flavors: \nJDIEventDataRequest\n and\n\nJDIEventFilter\n.\n\n\nData requests are used to collect information from an event and its\nassociated request and include it in callbacks and pipelines that expect\nevent data.\n\n\nFilters are used to narrow down which events trigger callbacks and get fed to\npipelines. Common use cases include filtering based on a provided unique id\nor custom property to a request (as the associated request is available in an\nevent).\n\n\nEvent Data Request\n\n\n\n\n\n\n\n\nCase Class\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nCustomPropertyDataRequest\n\n\nRetrieves a custom property from the request associated with the event.\n\n\n\n\n\n\n\n\nEvent Filter\n\n\n\n\n\n\n\n\nCase Class\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nMaxTriggerFilter\n\n\nLimits triggering of event callbacks and pipelines to the first N events.\n\n\n\n\n\n\nMinTriggerFilter\n\n\nLimits triggering of event callbacks and pipelines to all but the first N events.\n\n\n\n\n\n\nMethodNameFilter\n\n\nLimits triggering of event callbacks and pipelines if they are locatable to only those whose method name matches.\n\n\n\n\n\n\nCustomPropertyFilter\n\n\nLimits triggering of event callbacks and pipelines to events whose requests contain a matching custom property.\n\n\n\n\n\n\nUniquePRopertyFilter\n\n\nLimits triggering of event callbacks and pipelines to events whose requests contain a matching unique id.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCase Class\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nAndFilter\n\n\nCombines the truthiness of two other filters such that BOTH must allow the event.\n\n\n\n\n\n\nOrFilter\n\n\nCombines the truthiness of two other filters such that EITHER must allow the event.\n\n\n\n\n\n\nNotFilter\n\n\nFlips a filter such that an event is allowed only if the filter disallows the event.", 
            "title": "Using Extra Arguments for Requests"
        }, 
        {
            "location": "/advanced-topics/using-extra-arguments-for-requests/#using-extra-arguments-for-requests", 
            "text": "", 
            "title": "Using Extra Arguments for Requests"
        }, 
        {
            "location": "/advanced-topics/using-extra-arguments-for-requests/#overview", 
            "text": "With both profiles and the low-level API, you are able to provide extra\narguments in the form of  JDIArgument  or one of its derivatives: JDIRequestArgument  or  JDIEventArgument . The extra arguments are used to\nset additional configuration options on requests as well as provide additional\nfiltering and logic when receiving events.  Methods like  onBreakpoint  and  createBreakpointRequest  accept a variable\nnumber of extra arguments at the end of the method (defaulting to no extra\narguments).  val s: ScalaVirtualMachine = /* some virtual machine */\n\n// Set a custom property accessible on the request object AND limit reporting\n// to the first three occurrences\ns.onBreakpoint( file.scala , 37, CustomProperty( key ,  value ), MaxTriggerFilter(3))", 
            "title": "Overview"
        }, 
        {
            "location": "/advanced-topics/using-extra-arguments-for-requests/#request-arguments", 
            "text": "JDIRequestArgument  instances come in two flavors:  JDIRequestProperty  and JDIRequestFilter .  Properties are used to configure information about a request such as its\nsuspension level.  Filters are used to narrow down what a request reports. In the case of a\nbreakpoint request, you might limit the thread where the breakpoint can\noccur or the specific instance of a class that can trigger the event.  Request Properties     Case Class  Description      EnabledProperty  Sets whether or not the request is enabled.    SuspendPolicyProperty  Sets the suspend policy of the request.    CustomProperty  Adds a key/value pair to the request that can be referenced when receiving events for that request.    UniqueIdProperty  Adds a unique id to the request via a custom property.     Request Filters     Case Class  Description      ClassExclusionFilter  Limits reporting of events to only classes not specified by this filter.    ClassInclusionFilter  Limits reporting of events to only classes specified by this filter.    ClassReferenceFilter  Similar to  ClassInclusionFilter , but takes a  JDI   ReferenceType  instead of a string name.    CountFilter  Limits reporting to only occur after N-1 occurrences of the event. Furthermore, the event is only reported once.    InstanceFilter  Limits reporting of events to a specific instance of a class.    SourceNameFilter  Limits reporting of events to classes whose source name matches the specified pattern.    ThreadFilter  Limits reporting of events to the specific thread.", 
            "title": "Request Arguments"
        }, 
        {
            "location": "/advanced-topics/using-extra-arguments-for-requests/#event-arguments", 
            "text": "JDIEventArgument  instances come in two flavors:  JDIEventDataRequest  and JDIEventFilter .  Data requests are used to collect information from an event and its\nassociated request and include it in callbacks and pipelines that expect\nevent data.  Filters are used to narrow down which events trigger callbacks and get fed to\npipelines. Common use cases include filtering based on a provided unique id\nor custom property to a request (as the associated request is available in an\nevent).  Event Data Request     Case Class  Description      CustomPropertyDataRequest  Retrieves a custom property from the request associated with the event.     Event Filter     Case Class  Description      MaxTriggerFilter  Limits triggering of event callbacks and pipelines to the first N events.    MinTriggerFilter  Limits triggering of event callbacks and pipelines to all but the first N events.    MethodNameFilter  Limits triggering of event callbacks and pipelines if they are locatable to only those whose method name matches.    CustomPropertyFilter  Limits triggering of event callbacks and pipelines to events whose requests contain a matching custom property.    UniquePRopertyFilter  Limits triggering of event callbacks and pipelines to events whose requests contain a matching unique id.        Case Class  Description      AndFilter  Combines the truthiness of two other filters such that BOTH must allow the event.    OrFilter  Combines the truthiness of two other filters such that EITHER must allow the event.    NotFilter  Flips a filter such that an event is allowed only if the filter disallows the event.", 
            "title": "Event Arguments"
        }, 
        {
            "location": "/advanced-topics/making-requests-early/", 
            "text": "Making Requests Early\n\n\n\n\nOverview\n\n\nIn some situations, you might want or need to create \nJDI\n requests before the\ndebugger has connected to the target JVM. To do this, you can take advantage\nof the \nDummyScalaVirtualMachine\n to use the same API to create and manage\nyour requests and events \nbefore\n the target JVM starts.\n\n\nWhenever you call a function on a \nDummyScalaVirtualMachine\n, the underlying\nrequest is placed on a pending queue. When you provide the dummy VM to a\ndebugger, all of the pending requests are applied to each JVM that connects\nusing that debugger.\n\n\nCreating the dummy VM\n\n\nTo create a \nDummyScalaVirtualMachine\n that delegates all functions to be\nperformed when a real \nScalaVirtualMachine\n connects, you can use the\ncompanion object's helper method:\n\n\nval d: DummyScalaVirtualMachine = DummyScalaVirtualMachine.newInstance()\n\n\n\n\nUsing the dummy VM with debuggers\n\n\nWhen you have a \nDummyScalaVirtualMachine\n that you would like to apply to a\ndebugger, you can add it using \naddPendingScalaVirtualMachine\n or\n\nwithPending\n on the debugger.\n\n\nval debugger: Debugger = /* some debugger instance */\nval d: DummyScalaVirtualMachine = /* some dummy virtual machine */\n\n// Both operations perform the same task\ndebugger.addPendingScalaVirtualMachine(d)\ndebugger.withPending(d)\n\n\n\n\nLimitations of the dummy VM\n\n\nCurrently, there are a couple of limitations when using the\n\nDummyScalaVirtualMachine\n to prepare requests.\n\n\n\n\n\n\nYou cannot nest creation of event handlers within the callbacks of\n   other event handlers or pipelines.\n\n\nval d: DummyScalaVirtualMachine = /* some dummy virtual machine */\n\n// Will get evaluated\nd.createBreakpointRequest(\"file.scala\", 37)\n\n// Will get evaluated\nd.addResumingEventHandler(BreakpointEventType, e =\n {\n  val breakpointEvent = e.asInstanceOf[BreakpointEvent]\n\n  // Will never get evaluated\n  d.createStepOverLineRequest(breakpointEvent.thread())\n})\n\n\n\n\n\n\n\nYou cannot nest creation of pipelines within the callbacks of other\n   event handlers or pipelines.\n\n\nval d: DummyScalaVirtualMachine = /* some dummy virtual machine */\n\n// Will get evaluated\nd.onBreakpoint(\"file.scala\", 37).foreach(e =\n {\n  // Will never get evaluated\n  d.stepOverLine(e.thread())\n})\n\n\n\n\n\n\n\nYou cannot invoke \navailableLinesForFile\n as the target JVM needs to be\n   loaded to determine that information.\n\n\n\n\n\n\nYou cannot invoke \nmainClassName\n as the target JVM needs to be loaded to\n   determine that information.\n\n\n\n\n\n\nYou cannot invoke \ncommandLineArguments\n as the target JVM needs to be\n   loaded to determine that information.\n\n\n\n\n\n\nAny invocation on the dummy VM after the target JVM connects will not\n   be applied.", 
            "title": "Making Requests Early"
        }, 
        {
            "location": "/advanced-topics/making-requests-early/#making-requests-early", 
            "text": "", 
            "title": "Making Requests Early"
        }, 
        {
            "location": "/advanced-topics/making-requests-early/#overview", 
            "text": "In some situations, you might want or need to create  JDI  requests before the\ndebugger has connected to the target JVM. To do this, you can take advantage\nof the  DummyScalaVirtualMachine  to use the same API to create and manage\nyour requests and events  before  the target JVM starts.  Whenever you call a function on a  DummyScalaVirtualMachine , the underlying\nrequest is placed on a pending queue. When you provide the dummy VM to a\ndebugger, all of the pending requests are applied to each JVM that connects\nusing that debugger.", 
            "title": "Overview"
        }, 
        {
            "location": "/advanced-topics/making-requests-early/#creating-the-dummy-vm", 
            "text": "To create a  DummyScalaVirtualMachine  that delegates all functions to be\nperformed when a real  ScalaVirtualMachine  connects, you can use the\ncompanion object's helper method:  val d: DummyScalaVirtualMachine = DummyScalaVirtualMachine.newInstance()", 
            "title": "Creating the dummy VM"
        }, 
        {
            "location": "/advanced-topics/making-requests-early/#using-the-dummy-vm-with-debuggers", 
            "text": "When you have a  DummyScalaVirtualMachine  that you would like to apply to a\ndebugger, you can add it using  addPendingScalaVirtualMachine  or withPending  on the debugger.  val debugger: Debugger = /* some debugger instance */\nval d: DummyScalaVirtualMachine = /* some dummy virtual machine */\n\n// Both operations perform the same task\ndebugger.addPendingScalaVirtualMachine(d)\ndebugger.withPending(d)", 
            "title": "Using the dummy VM with debuggers"
        }, 
        {
            "location": "/advanced-topics/making-requests-early/#limitations-of-the-dummy-vm", 
            "text": "Currently, there are a couple of limitations when using the DummyScalaVirtualMachine  to prepare requests.    You cannot nest creation of event handlers within the callbacks of\n   other event handlers or pipelines.  val d: DummyScalaVirtualMachine = /* some dummy virtual machine */\n\n// Will get evaluated\nd.createBreakpointRequest(\"file.scala\", 37)\n\n// Will get evaluated\nd.addResumingEventHandler(BreakpointEventType, e =  {\n  val breakpointEvent = e.asInstanceOf[BreakpointEvent]\n\n  // Will never get evaluated\n  d.createStepOverLineRequest(breakpointEvent.thread())\n})    You cannot nest creation of pipelines within the callbacks of other\n   event handlers or pipelines.  val d: DummyScalaVirtualMachine = /* some dummy virtual machine */\n\n// Will get evaluated\nd.onBreakpoint(\"file.scala\", 37).foreach(e =  {\n  // Will never get evaluated\n  d.stepOverLine(e.thread())\n})    You cannot invoke  availableLinesForFile  as the target JVM needs to be\n   loaded to determine that information.    You cannot invoke  mainClassName  as the target JVM needs to be loaded to\n   determine that information.    You cannot invoke  commandLineArguments  as the target JVM needs to be\n   loaded to determine that information.    Any invocation on the dummy VM after the target JVM connects will not\n   be applied.", 
            "title": "Limitations of the dummy VM"
        }, 
        {
            "location": "/cookbook/creating-a-launching-debugger/", 
            "text": "Creating a Launching Debugger\n\n\n\n\nOverview\n\n\nThe following is a brief example of using the launching debugger to start\na target JVM process and connect to it for debugging purposes.\n\n\nCode\n\n\nLaunchingDebuggerExample.scala\n\n\nimport org.scaladebugger.api.debuggers.LaunchingDebugger\nimport org.scaladebugger.api.utils.JDITools\n\n/**\n * Launches a target JVM process and connects to it using the\n * launching debugger.\n */\nobject LaunchingDebuggerExample extends App {\n  // Get the executing class name (remove $ from object class name)\n  val klass = SomeLaunchingMainClass.getClass\n  val className = klass.getName.replaceAllLiterally(\n$\n, \n)\n\n  // Add our main class to the classpath used to launch the class\n  val classpath = JDITools.jvmClassPath\n  val jvmOptions = Seq(\n-classpath\n, classpath)\n\n  val launchingDebugger = LaunchingDebugger(\n    className = className,\n    jvmOptions = jvmOptions,\n    suspend = true // Wait to start the main class until after connected\n  )\n\n  launchingDebugger.start { s =\n\n    println(\nLaunched and connected to JVM: \n + s.uniqueId)\n\n    // Shuts down the launched target JVM and our debugger\n    launchingDebugger.stop()\n  }\n\n  // Keep the sample program running while our debugger is running\n  while (launchingDebugger.isRunning) Thread.sleep(1)\n}\n\n\n\n\nSomeLaunchingMainClass.scala\n\n\n/**\n * Sample main class that does nothing.\n */\nobject SomeLaunchingMainClass {\n  def main(args: Array[String]): Unit = {\n    // Does nothing\n  }\n}", 
            "title": "Creating a Launching Debugger"
        }, 
        {
            "location": "/cookbook/creating-a-launching-debugger/#creating-a-launching-debugger", 
            "text": "", 
            "title": "Creating a Launching Debugger"
        }, 
        {
            "location": "/cookbook/creating-a-launching-debugger/#overview", 
            "text": "The following is a brief example of using the launching debugger to start\na target JVM process and connect to it for debugging purposes.", 
            "title": "Overview"
        }, 
        {
            "location": "/cookbook/creating-a-launching-debugger/#code", 
            "text": "LaunchingDebuggerExample.scala  import org.scaladebugger.api.debuggers.LaunchingDebugger\nimport org.scaladebugger.api.utils.JDITools\n\n/**\n * Launches a target JVM process and connects to it using the\n * launching debugger.\n */\nobject LaunchingDebuggerExample extends App {\n  // Get the executing class name (remove $ from object class name)\n  val klass = SomeLaunchingMainClass.getClass\n  val className = klass.getName.replaceAllLiterally( $ ,  )\n\n  // Add our main class to the classpath used to launch the class\n  val classpath = JDITools.jvmClassPath\n  val jvmOptions = Seq( -classpath , classpath)\n\n  val launchingDebugger = LaunchingDebugger(\n    className = className,\n    jvmOptions = jvmOptions,\n    suspend = true // Wait to start the main class until after connected\n  )\n\n  launchingDebugger.start { s = \n    println( Launched and connected to JVM:   + s.uniqueId)\n\n    // Shuts down the launched target JVM and our debugger\n    launchingDebugger.stop()\n  }\n\n  // Keep the sample program running while our debugger is running\n  while (launchingDebugger.isRunning) Thread.sleep(1)\n}  SomeLaunchingMainClass.scala  /**\n * Sample main class that does nothing.\n */\nobject SomeLaunchingMainClass {\n  def main(args: Array[String]): Unit = {\n    // Does nothing\n  }\n}", 
            "title": "Code"
        }, 
        {
            "location": "/cookbook/creating-an-attaching-debugger/", 
            "text": "Creating an Attaching Debugger\n\n\n\n\nOverview\n\n\nThe following is a brief example of using the attaching debugger to connect\nto an already-running target JVM process that has been started with proper\nJDWP options.\n\n\nThe target JVM is started separately in the example code using\n\nJDITools.spawn\n.\n\n\nCode\n\n\nAttachingDebuggerExample.scala\n\n\nimport org.scaladebugger.api.debuggers.AttachingDebugger\nimport org.scaladebugger.api.utils.JDITools\n\n/**\n * Starts a target JVM process and connects to it using the\n * attaching debugger.\n */\nobject AttachingDebuggerExample extends App {\n  // Get the executing class name (remove $ from object class name)\n  val klass = SomeAttachingMainClass.getClass\n  val className = klass.getName.replaceAllLiterally(\n$\n, \n)\n\n  // Spawn the target JVM process using our helper function\n  val targetJvmProcess = JDITools.spawn(\n    className = className,\n    port = 5005,\n    suspend = true // Wait to start the main class until after connected\n  )\n\n  val attachingDebugger = AttachingDebugger(port = 5005)\n\n  attachingDebugger.start { s =\n\n    println(\nAttached to JVM: \n + s.uniqueId)\n\n    // Shuts down our debugger\n    attachingDebugger.stop()\n\n    // Shuts down the remote process\n    targetJvmProcess.destroy()\n  }\n\n  // Keep the sample program running while our debugger is running\n  while (attachingDebugger.isRunning) Thread.sleep(1)\n}\n\n\n\n\nSomeAttachingMainClass.scala\n\n\n/**\n * Sample main class that does nothing.\n */\nobject SomeAttachingMainClass {\n  def main(args: Array[String]): Unit = {\n    // Does nothing\n  }\n}", 
            "title": "Creating an Attaching Debugger"
        }, 
        {
            "location": "/cookbook/creating-an-attaching-debugger/#creating-an-attaching-debugger", 
            "text": "", 
            "title": "Creating an Attaching Debugger"
        }, 
        {
            "location": "/cookbook/creating-an-attaching-debugger/#overview", 
            "text": "The following is a brief example of using the attaching debugger to connect\nto an already-running target JVM process that has been started with proper\nJDWP options.  The target JVM is started separately in the example code using JDITools.spawn .", 
            "title": "Overview"
        }, 
        {
            "location": "/cookbook/creating-an-attaching-debugger/#code", 
            "text": "AttachingDebuggerExample.scala  import org.scaladebugger.api.debuggers.AttachingDebugger\nimport org.scaladebugger.api.utils.JDITools\n\n/**\n * Starts a target JVM process and connects to it using the\n * attaching debugger.\n */\nobject AttachingDebuggerExample extends App {\n  // Get the executing class name (remove $ from object class name)\n  val klass = SomeAttachingMainClass.getClass\n  val className = klass.getName.replaceAllLiterally( $ ,  )\n\n  // Spawn the target JVM process using our helper function\n  val targetJvmProcess = JDITools.spawn(\n    className = className,\n    port = 5005,\n    suspend = true // Wait to start the main class until after connected\n  )\n\n  val attachingDebugger = AttachingDebugger(port = 5005)\n\n  attachingDebugger.start { s = \n    println( Attached to JVM:   + s.uniqueId)\n\n    // Shuts down our debugger\n    attachingDebugger.stop()\n\n    // Shuts down the remote process\n    targetJvmProcess.destroy()\n  }\n\n  // Keep the sample program running while our debugger is running\n  while (attachingDebugger.isRunning) Thread.sleep(1)\n}  SomeAttachingMainClass.scala  /**\n * Sample main class that does nothing.\n */\nobject SomeAttachingMainClass {\n  def main(args: Array[String]): Unit = {\n    // Does nothing\n  }\n}", 
            "title": "Code"
        }, 
        {
            "location": "/cookbook/creating-a-listening-debugger/", 
            "text": "Creating a Listening Debugger\n\n\n\n\nOverview\n\n\nThe following is a brief example of using the listening debugger to receive\nconnections from target JVM processes.\n\n\nThe target JVM is started separately in the example code using\n\nJDITools.spawn\n.\n\n\nCode\n\n\nListeningDebuggerExample.scala\n\n\nimport org.scaladebugger.api.debuggers.ListeningDebugger\nimport org.scaladebugger.api.utils.JDITools\n\n/**\n * Starts a target JVM process and connects to it using the\n * listening debugger.\n */\nobject ListeningDebuggerExample extends App {\n  // Get the executing class name (remove $ from object class name)\n  val klass = SomeListeningMainClass.getClass\n  val className = klass.getName.replaceAllLiterally(\n$\n, \n)\n\n  val listeningDebugger = ListeningDebugger(port = 5005)\n\n  listeningDebugger.start { s =\n\n    println(\nReceived connection from JVM: \n + s.uniqueId)\n\n    // Shuts down our debugger\n    listeningDebugger.stop()\n\n    // Shuts down the remote process\n    targetJvmProcess.destroy()\n  }\n\n  // Spawn the target JVM process using our helper function\n  val targetJvmProcess = JDITools.spawn(\n    className = className,\n    port = 5005,\n    server = false, // Don't listen for connections but instead do\n                    // the connecting\n    suspend = true // Wait to start the main class until after connected\n  )\n\n  // Keep the sample program running while our debugger is running\n  while (listeningDebugger.isRunning) Thread.sleep(1)\n}\n\n\n\n\nSomeListeningMainClass.scala\n\n\n/**\n * Sample main class that does nothing.\n */\nobject SomeListeningMainClass {\n  def main(args: Array[String]): Unit = {\n    // Does nothing\n  }\n}", 
            "title": "Creating a Listening Debugger"
        }, 
        {
            "location": "/cookbook/creating-a-listening-debugger/#creating-a-listening-debugger", 
            "text": "", 
            "title": "Creating a Listening Debugger"
        }, 
        {
            "location": "/cookbook/creating-a-listening-debugger/#overview", 
            "text": "The following is a brief example of using the listening debugger to receive\nconnections from target JVM processes.  The target JVM is started separately in the example code using JDITools.spawn .", 
            "title": "Overview"
        }, 
        {
            "location": "/cookbook/creating-a-listening-debugger/#code", 
            "text": "ListeningDebuggerExample.scala  import org.scaladebugger.api.debuggers.ListeningDebugger\nimport org.scaladebugger.api.utils.JDITools\n\n/**\n * Starts a target JVM process and connects to it using the\n * listening debugger.\n */\nobject ListeningDebuggerExample extends App {\n  // Get the executing class name (remove $ from object class name)\n  val klass = SomeListeningMainClass.getClass\n  val className = klass.getName.replaceAllLiterally( $ ,  )\n\n  val listeningDebugger = ListeningDebugger(port = 5005)\n\n  listeningDebugger.start { s = \n    println( Received connection from JVM:   + s.uniqueId)\n\n    // Shuts down our debugger\n    listeningDebugger.stop()\n\n    // Shuts down the remote process\n    targetJvmProcess.destroy()\n  }\n\n  // Spawn the target JVM process using our helper function\n  val targetJvmProcess = JDITools.spawn(\n    className = className,\n    port = 5005,\n    server = false, // Don't listen for connections but instead do\n                    // the connecting\n    suspend = true // Wait to start the main class until after connected\n  )\n\n  // Keep the sample program running while our debugger is running\n  while (listeningDebugger.isRunning) Thread.sleep(1)\n}  SomeListeningMainClass.scala  /**\n * Sample main class that does nothing.\n */\nobject SomeListeningMainClass {\n  def main(args: Array[String]): Unit = {\n    // Does nothing\n  }\n}", 
            "title": "Code"
        }, 
        {
            "location": "/cookbook/creating-a-breakpoint/", 
            "text": "Creating a Breakpoint\n\n\n\n\nOverview\n\n\nThe following demonstrates setting and hitting a breakpoint using the default\nprofile on \nScalaVirtualMachine\n.\n\n\nCode\n\n\nSingleBreakpointExample.scala\n\n\nimport org.scaladebugger.api.debuggers.LaunchingDebugger\nimport org.scaladebugger.api.utils.JDITools\n\n/**\n * Creates a single breakpoint to demonstrate the process.\n */\nobject SingleBreakpointExample extends App {\n  // Get the executing class name (remove $ from object class name)\n  val klass = SingleBreakpointMainClass.getClass\n  val className = klass.getName.replaceAllLiterally(\n$\n, \n)\n\n  // Add our main class to the classpath used to launch the class\n  val classpath = JDITools.jvmClassPath\n  val jvmOptions = Seq(\n-classpath\n, classpath)\n\n  val launchingDebugger = LaunchingDebugger(\n    className = className,\n    jvmOptions = jvmOptions,\n    suspend = true // Wait to start the main class until after connected\n  )\n\n  launchingDebugger.start { s =\n\n    println(\nLaunched and connected to JVM: \n + s.uniqueId)\n\n    // Files are in the form of package/structure/to/class.scala\n    val fileName = JDITools.scalaClassStringToFileString(className)\n    val lineNumber = 7\n\n    // On reaching a breakpoint for our class below, print out our result\n    // and shut down our debugger\n    s.onUnsafeBreakpoint(fileName, lineNumber).foreach(e =\n {\n      val path = e.location().sourcePath()\n      val line = e.location().lineNumber()\n\n      println(s\nReached breakpoint for $path:$line\n)\n      launchingDebugger.stop()\n    })\n  }\n\n  // Keep the sample program running while our debugger is running\n  while (launchingDebugger.isRunning) Thread.sleep(1)\n}\n\n\n\n\nSingleBreakpointMainClass.scala\n\n\n// NOTE: Make sure that the line marked as breakpoint is ACTUALLY on line 7\n\nobject SingleBreakpointMainClass {\n  def main(args: Array[String]): Unit = {\n    def noop(): Unit = {}\n    while (true) {\n      noop() // Breakpoint line is 7\n    }\n  }\n}", 
            "title": "Creating a Breakpoint"
        }, 
        {
            "location": "/cookbook/creating-a-breakpoint/#creating-a-breakpoint", 
            "text": "", 
            "title": "Creating a Breakpoint"
        }, 
        {
            "location": "/cookbook/creating-a-breakpoint/#overview", 
            "text": "The following demonstrates setting and hitting a breakpoint using the default\nprofile on  ScalaVirtualMachine .", 
            "title": "Overview"
        }, 
        {
            "location": "/cookbook/creating-a-breakpoint/#code", 
            "text": "SingleBreakpointExample.scala  import org.scaladebugger.api.debuggers.LaunchingDebugger\nimport org.scaladebugger.api.utils.JDITools\n\n/**\n * Creates a single breakpoint to demonstrate the process.\n */\nobject SingleBreakpointExample extends App {\n  // Get the executing class name (remove $ from object class name)\n  val klass = SingleBreakpointMainClass.getClass\n  val className = klass.getName.replaceAllLiterally( $ ,  )\n\n  // Add our main class to the classpath used to launch the class\n  val classpath = JDITools.jvmClassPath\n  val jvmOptions = Seq( -classpath , classpath)\n\n  val launchingDebugger = LaunchingDebugger(\n    className = className,\n    jvmOptions = jvmOptions,\n    suspend = true // Wait to start the main class until after connected\n  )\n\n  launchingDebugger.start { s = \n    println( Launched and connected to JVM:   + s.uniqueId)\n\n    // Files are in the form of package/structure/to/class.scala\n    val fileName = JDITools.scalaClassStringToFileString(className)\n    val lineNumber = 7\n\n    // On reaching a breakpoint for our class below, print out our result\n    // and shut down our debugger\n    s.onUnsafeBreakpoint(fileName, lineNumber).foreach(e =  {\n      val path = e.location().sourcePath()\n      val line = e.location().lineNumber()\n\n      println(s Reached breakpoint for $path:$line )\n      launchingDebugger.stop()\n    })\n  }\n\n  // Keep the sample program running while our debugger is running\n  while (launchingDebugger.isRunning) Thread.sleep(1)\n}  SingleBreakpointMainClass.scala  // NOTE: Make sure that the line marked as breakpoint is ACTUALLY on line 7\n\nobject SingleBreakpointMainClass {\n  def main(args: Array[String]): Unit = {\n    def noop(): Unit = {}\n    while (true) {\n      noop() // Breakpoint line is 7\n    }\n  }\n}", 
            "title": "Code"
        }, 
        {
            "location": "/cookbook/stepping-over-a-line-of-code/", 
            "text": "Stepping over a Line of Code\n\n\n\n\nOverview\n\n\nThe following demonstrates stepping over a line of code once a breakpoint\nhas been hit. This is using the default profile in \nScalaVirtualMachine\n.\n\n\nCode\n\n\nSingleStepExample.scala\n\n\nimport org.scaladebugger.api.debuggers.LaunchingDebugger\nimport org.scaladebugger.api.utils.JDITools\n\n/**\n * Creates a single step to demonstrate the process.\n */\nobject SingleStepExample extends App {\n  // Get the executing class name (remove $ from object class name)\n  val klass = SingleStepMainClass.getClass\n  val className = klass.getName.replaceAllLiterally(\n$\n, \n)\n\n  // Add our main class to the classpath used to launch the class\n  val classpath = JDITools.jvmClassPath\n  val jvmOptions = Seq(\n-classpath\n, classpath)\n\n  val launchingDebugger = LaunchingDebugger(\n    className = className,\n    jvmOptions = jvmOptions,\n    suspend = true // Wait to start the main class until after connected\n  )\n\n  launchingDebugger.start { s =\n\n    println(\nLaunched and connected to JVM: \n + s.uniqueId)\n\n    // Files are in the form of package/structure/to/class.scala\n    val fileName = JDITools.scalaClassStringToFileString(className)\n    val lineNumber = 7\n\n    // On reaching a breakpoint for our class below, step to the next\n    // line and then shutdown our debugger\n    s.onUnsafeBreakpoint(fileName, lineNumber).foreach(be =\n {\n      val path = be.location().sourcePath()\n      val line = be.location().lineNumber()\n\n      println(s\nReached breakpoint for $path:$line\n)\n\n      // Step methods return a future that occurs when the step finishes\n      import scala.concurrent.ExecutionContext.Implicits.global\n      s.stepOverLine(be.thread()).foreach(se =\n {\n        val path = se.location().sourcePath()\n        val line = se.location().lineNumber()\n\n        println(s\nStepped to $path:$line\n)\n        launchingDebugger.stop()\n      })\n    })\n  }\n\n  // Keep the sample program running while our debugger is running\n  while (launchingDebugger.isRunning) Thread.sleep(1)\n}\n\n\n\n\nSingleStepMainClass.scala\n\n\n// NOTE: Make sure that the line marked as breakpoint is ACTUALLY on line 7\n\nobject SingleStepMainClass {\n  def main(args: Array[String]): Unit = {\n    def noop(): Unit = {}\n    while (true) {\n      noop() // Breakpoint line is 7\n      noop() // Step over should reach here\n    }\n  }\n}", 
            "title": "Stepping over a Line of Code"
        }, 
        {
            "location": "/cookbook/stepping-over-a-line-of-code/#stepping-over-a-line-of-code", 
            "text": "", 
            "title": "Stepping over a Line of Code"
        }, 
        {
            "location": "/cookbook/stepping-over-a-line-of-code/#overview", 
            "text": "The following demonstrates stepping over a line of code once a breakpoint\nhas been hit. This is using the default profile in  ScalaVirtualMachine .", 
            "title": "Overview"
        }, 
        {
            "location": "/cookbook/stepping-over-a-line-of-code/#code", 
            "text": "SingleStepExample.scala  import org.scaladebugger.api.debuggers.LaunchingDebugger\nimport org.scaladebugger.api.utils.JDITools\n\n/**\n * Creates a single step to demonstrate the process.\n */\nobject SingleStepExample extends App {\n  // Get the executing class name (remove $ from object class name)\n  val klass = SingleStepMainClass.getClass\n  val className = klass.getName.replaceAllLiterally( $ ,  )\n\n  // Add our main class to the classpath used to launch the class\n  val classpath = JDITools.jvmClassPath\n  val jvmOptions = Seq( -classpath , classpath)\n\n  val launchingDebugger = LaunchingDebugger(\n    className = className,\n    jvmOptions = jvmOptions,\n    suspend = true // Wait to start the main class until after connected\n  )\n\n  launchingDebugger.start { s = \n    println( Launched and connected to JVM:   + s.uniqueId)\n\n    // Files are in the form of package/structure/to/class.scala\n    val fileName = JDITools.scalaClassStringToFileString(className)\n    val lineNumber = 7\n\n    // On reaching a breakpoint for our class below, step to the next\n    // line and then shutdown our debugger\n    s.onUnsafeBreakpoint(fileName, lineNumber).foreach(be =  {\n      val path = be.location().sourcePath()\n      val line = be.location().lineNumber()\n\n      println(s Reached breakpoint for $path:$line )\n\n      // Step methods return a future that occurs when the step finishes\n      import scala.concurrent.ExecutionContext.Implicits.global\n      s.stepOverLine(be.thread()).foreach(se =  {\n        val path = se.location().sourcePath()\n        val line = se.location().lineNumber()\n\n        println(s Stepped to $path:$line )\n        launchingDebugger.stop()\n      })\n    })\n  }\n\n  // Keep the sample program running while our debugger is running\n  while (launchingDebugger.isRunning) Thread.sleep(1)\n}  SingleStepMainClass.scala  // NOTE: Make sure that the line marked as breakpoint is ACTUALLY on line 7\n\nobject SingleStepMainClass {\n  def main(args: Array[String]): Unit = {\n    def noop(): Unit = {}\n    while (true) {\n      noop() // Breakpoint line is 7\n      noop() // Step over should reach here\n    }\n  }\n}", 
            "title": "Code"
        }, 
        {
            "location": "/cookbook/watching-modification-of-a-class-variable/", 
            "text": "Watching Modification of a Class Variable\n\n\n\n\nOverview\n\n\nThe following demonstrates watching and receiving a notification when a\nvariable is modified. This is using the default profile in\n\nScalaVirtualMachine\n.\n\n\nCode\n\n\nSingleWatchpointExample.scala\n\n\nimport org.scaladebugger.api.debuggers.LaunchingDebugger\nimport org.scaladebugger.api.utils.JDITools\n\n/**\n * Creates a single step to demonstrate the process.\n */\nobject SingleWatchpointExample extends App {\n  // Get the executing class name (remove $ from object class name)\n  val klass = SingleWatchpointMainClass.getClass\n  val className = klass.getName.replaceAllLiterally(\n$\n, \n)\n\n  // Add our main class to the classpath used to launch the class\n  val classpath = JDITools.jvmClassPath\n  val jvmOptions = Seq(\n-classpath\n, classpath)\n\n  val launchingDebugger = LaunchingDebugger(\n    className = className,\n    jvmOptions = jvmOptions,\n    suspend = true // Wait to start the main class until after connected\n  )\n\n  launchingDebugger.start { s =\n\n    println(\nLaunched and connected to JVM: \n + s.uniqueId)\n\n    val otherClassName = classOf[SingleWatchpointOtherClass].getName\n    val fieldName = \nx\n\n\n    println(s\nWatching $otherClassName.$fieldName\n)\n    s.onUnsafeModificationWatchpoint(otherClassName, fieldName).foreach(e =\n {\n      // Implicit enables conversion of standard value to wrapper value\n      // that we use to extract the value locally\n      import org.scaladebugger.api.lowlevel.wrappers.Implicits._\n\n      val className = e.field().declaringType().name()\n      val fieldName = e.field().name()\n      val newValue = e.valueToBe().value()\n\n      println(s\n$className field $fieldName was updated to $newValue\n)\n      launchingDebugger.stop()\n    })\n  }\n\n  // Keep the sample program running while our debugger is running\n  while (launchingDebugger.isRunning) Thread.sleep(1)\n}\n\n\n\n\nSingleWatchpointMainClass.scala\n\n\nobject SingleWatchpointMainClass {\n  def main(args: Array[String]): Unit = {\n    val otherClass = new SingleWatchpointOtherClass\n\n    while (true) {\n      otherClass.x += 1\n    }\n  }\n}\n\nclass SingleWatchpointOtherClass {\n  var x: Int = 0\n}", 
            "title": "Watching Modification of a Class Variable"
        }, 
        {
            "location": "/cookbook/watching-modification-of-a-class-variable/#watching-modification-of-a-class-variable", 
            "text": "", 
            "title": "Watching Modification of a Class Variable"
        }, 
        {
            "location": "/cookbook/watching-modification-of-a-class-variable/#overview", 
            "text": "The following demonstrates watching and receiving a notification when a\nvariable is modified. This is using the default profile in ScalaVirtualMachine .", 
            "title": "Overview"
        }, 
        {
            "location": "/cookbook/watching-modification-of-a-class-variable/#code", 
            "text": "SingleWatchpointExample.scala  import org.scaladebugger.api.debuggers.LaunchingDebugger\nimport org.scaladebugger.api.utils.JDITools\n\n/**\n * Creates a single step to demonstrate the process.\n */\nobject SingleWatchpointExample extends App {\n  // Get the executing class name (remove $ from object class name)\n  val klass = SingleWatchpointMainClass.getClass\n  val className = klass.getName.replaceAllLiterally( $ ,  )\n\n  // Add our main class to the classpath used to launch the class\n  val classpath = JDITools.jvmClassPath\n  val jvmOptions = Seq( -classpath , classpath)\n\n  val launchingDebugger = LaunchingDebugger(\n    className = className,\n    jvmOptions = jvmOptions,\n    suspend = true // Wait to start the main class until after connected\n  )\n\n  launchingDebugger.start { s = \n    println( Launched and connected to JVM:   + s.uniqueId)\n\n    val otherClassName = classOf[SingleWatchpointOtherClass].getName\n    val fieldName =  x \n\n    println(s Watching $otherClassName.$fieldName )\n    s.onUnsafeModificationWatchpoint(otherClassName, fieldName).foreach(e =  {\n      // Implicit enables conversion of standard value to wrapper value\n      // that we use to extract the value locally\n      import org.scaladebugger.api.lowlevel.wrappers.Implicits._\n\n      val className = e.field().declaringType().name()\n      val fieldName = e.field().name()\n      val newValue = e.valueToBe().value()\n\n      println(s $className field $fieldName was updated to $newValue )\n      launchingDebugger.stop()\n    })\n  }\n\n  // Keep the sample program running while our debugger is running\n  while (launchingDebugger.isRunning) Thread.sleep(1)\n}  SingleWatchpointMainClass.scala  object SingleWatchpointMainClass {\n  def main(args: Array[String]): Unit = {\n    val otherClass = new SingleWatchpointOtherClass\n\n    while (true) {\n      otherClass.x += 1\n    }\n  }\n}\n\nclass SingleWatchpointOtherClass {\n  var x: Int = 0\n}", 
            "title": "Code"
        }, 
        {
            "location": "/external/scaladoc-2.10/", 
            "text": "Scaladoc 2.10\n\n\n\n\nPlease Wait\n\n\nRedirecting you to \nhere\n.\n\n\n\n    window.location = \"http://www.javadoc.io/doc/org.scala-debugger/scala-debugger-api_2.10/\"", 
            "title": "Scaladoc 2.10"
        }, 
        {
            "location": "/external/scaladoc-2.10/#scaladoc-210", 
            "text": "", 
            "title": "Scaladoc 2.10"
        }, 
        {
            "location": "/external/scaladoc-2.10/#please-wait", 
            "text": "Redirecting you to  here .  \n    window.location = \"http://www.javadoc.io/doc/org.scala-debugger/scala-debugger-api_2.10/\"", 
            "title": "Please Wait"
        }, 
        {
            "location": "/external/scaladoc-2.11/", 
            "text": "Scaladoc 2.11\n\n\n\n\nPlease Wait\n\n\nRedirecting you to \nhere\n.\n\n\n\n    window.location = \"http://www.javadoc.io/doc/org.scala-debugger/scala-debugger-api_2.11/\"", 
            "title": "Scaladoc 2.11"
        }, 
        {
            "location": "/external/scaladoc-2.11/#scaladoc-211", 
            "text": "", 
            "title": "Scaladoc 2.11"
        }, 
        {
            "location": "/external/scaladoc-2.11/#please-wait", 
            "text": "Redirecting you to  here .  \n    window.location = \"http://www.javadoc.io/doc/org.scala-debugger/scala-debugger-api_2.11/\"", 
            "title": "Please Wait"
        }, 
        {
            "location": "/about/roadmap/", 
            "text": "Roadmap\n\n\nContains the current roadmap for the next significant release to the\nScala debugger API and tooling. The versioning is \nMAJOR.MINOR.REVISION\n\nwhere a major release indicates breaking API changes, a minor release\nindicates new features, and a revision update indicates bug fixes.\n\n\n\n\nVersion 1.1.0\n\n\n\n\nSee the \nwiki\n for the current roadmap!\n\n\n\n\nVersion 1.0.0\n\n\n\n\nCreate high-level profile system (only pure profile needed now)\n\n\nCreate low-level managers for \nJDI\n requests\n\n\nAdd support for pending requests to be applied as soon as possible\n\n\nArchitect \"extra argument\" system\n\n\nCreate documentation website", 
            "title": "Roadmap"
        }, 
        {
            "location": "/about/roadmap/#roadmap", 
            "text": "Contains the current roadmap for the next significant release to the\nScala debugger API and tooling. The versioning is  MAJOR.MINOR.REVISION \nwhere a major release indicates breaking API changes, a minor release\nindicates new features, and a revision update indicates bug fixes.", 
            "title": "Roadmap"
        }, 
        {
            "location": "/about/roadmap/#version-110", 
            "text": "See the  wiki  for the current roadmap!", 
            "title": "Version 1.1.0"
        }, 
        {
            "location": "/about/roadmap/#version-100", 
            "text": "Create high-level profile system (only pure profile needed now)  Create low-level managers for  JDI  requests  Add support for pending requests to be applied as soon as possible  Architect \"extra argument\" system  Create documentation website", 
            "title": "Version 1.0.0"
        }, 
        {
            "location": "/about/release-notes/", 
            "text": "Release Notes\n\n\n\n\nVersion 1.0.0 (2015-12-23)\n\n\n\n\nAdded high-level pure profile\n\n\nImplemented caching in pure profile traits\n\n\n\n\n\n\nAdded high-level swappable profile used by \nScalaVirtualMachine\n to\n  give the appearance of one API but utilize different APIs underneath\n  that can be decided upon programmatically\n\n\nAdded pipelines to simulate stream of events in same fashion as\n  Apache Spark streaming\n\n\nAdded \nJDIArgument\n support in low-level and high-level APIs\n\n\nImplemented filters and filter processing for events\n\n\nImplemented data retrieval and data retrieval processing for events\n\n\nImplemented property/filter configuring for requests\n\n\n\n\n\n\nAdded dummy implementations of low-level APIs\n\n\nImplemented utilization of dummy APIs to set desired requests\n  before virtual machine is started\n\n\n\n\n\n\nAdded profile manager to organize available profiles\n\n\nCompleted missing low-level request management\n\n\nAdded low-level access watchpoint request management\n\n\nAdded low-level class prepare request management\n\n\nAdded low-level class unload request management\n\n\nAdded low-level exception request management\n\n\nAdded low-level modification watchpoint request management\n\n\nAdded low-level monitor contended entered request management\n\n\nAdded low-level monitor contended enter request management\n\n\nAdded low-level monitor waited request management\n\n\nAdded low-level monitor wait request management\n\n\nAdded low-level method entry request management\n\n\nAdded low-level method exit request management\n\n\nAdded low-level thread death request management\n\n\nAdded low-level thread start request management\n\n\nAdded low-level vm death request management\n\n\n\n\n\n\n\n\n\n\nVersion senkbeil (2015-07-11)\n\n\n\n\nNote:\n\n\nReleased under \norg.senkbeil\n as version \n1.0.0\n.\n\n\nThis was the only version released using the \norg.senkbeil\n name and is\nincompatible with any other release.\n\n\n\n\n\n\nAdded low-level breakpoint creation and event handling\n\n\nAdded low-level step creation and event handling\n\n\nAdded wrappers around stack frames, thread references, reference types,\n  and values", 
            "title": "Release Notes"
        }, 
        {
            "location": "/about/release-notes/#release-notes", 
            "text": "", 
            "title": "Release Notes"
        }, 
        {
            "location": "/about/release-notes/#version-100-2015-12-23", 
            "text": "Added high-level pure profile  Implemented caching in pure profile traits    Added high-level swappable profile used by  ScalaVirtualMachine  to\n  give the appearance of one API but utilize different APIs underneath\n  that can be decided upon programmatically  Added pipelines to simulate stream of events in same fashion as\n  Apache Spark streaming  Added  JDIArgument  support in low-level and high-level APIs  Implemented filters and filter processing for events  Implemented data retrieval and data retrieval processing for events  Implemented property/filter configuring for requests    Added dummy implementations of low-level APIs  Implemented utilization of dummy APIs to set desired requests\n  before virtual machine is started    Added profile manager to organize available profiles  Completed missing low-level request management  Added low-level access watchpoint request management  Added low-level class prepare request management  Added low-level class unload request management  Added low-level exception request management  Added low-level modification watchpoint request management  Added low-level monitor contended entered request management  Added low-level monitor contended enter request management  Added low-level monitor waited request management  Added low-level monitor wait request management  Added low-level method entry request management  Added low-level method exit request management  Added low-level thread death request management  Added low-level thread start request management  Added low-level vm death request management", 
            "title": "Version 1.0.0 (2015-12-23)"
        }, 
        {
            "location": "/about/release-notes/#version-senkbeil-2015-07-11", 
            "text": "Note:  Released under  org.senkbeil  as version  1.0.0 .  This was the only version released using the  org.senkbeil  name and is\nincompatible with any other release.    Added low-level breakpoint creation and event handling  Added low-level step creation and event handling  Added wrappers around stack frames, thread references, reference types,\n  and values", 
            "title": "Version senkbeil (2015-07-11)"
        }, 
        {
            "location": "/about/contributing/", 
            "text": "Contributing to the Scala Debugger\n\n\nOverview\n\n\nAll contributions are welcome! As a reminder, project is licensed under the\n\nApache 2.0 license\n.\n\n\n\n\n\n\nFork the repository\n.\n\n\n\n\n\n\nClone your forked version of the repository.\n\n\ngit clone git@github.com:your-username/scala-debugger.git\n\n\n\n\n\n\n\nAdd your code and associated tests. All code-related changes are expected\n   to either add new tests or update existing ones.\n\n\n\n\n\n\nValidate that your changes pass the existing tests along with your own.\n\n\nsbt test it:test\n\n\n\n\n\n\n\nIf relevant (new features, modifying existing features), please update\n   the documentation in \ndocs/\n.\n\n\n\n\n\n\nPush your fork and \nsubmit a pull request\n.\n\n\n\n\n\n\nDeveloper Notes\n\n\nPotential Gotchas\n\n\n\n\n\n\nWhen moving from Mac OS X's IntelliJ to the IntelliJ of Linux Mint, the\n  tools.jar of OpenJDK/Oracle JDK was not picked up. I needed to manually open\n  up the SDK being used and add the tools.jar of \n  \n/usr/lib/jvm/java-7-openjdk-amd64/lib/\n to the classpath. This allows me to\n  use the Sun-based \ncom.sun.jdi\n package for a Java debugger interface rather\n  than C++.\n\n\n\n\n\n\nWhen using the launching debugger, I noticed that it was creating an address\n  of senkbeil.org:RANDOMPORT. \nsenkbeil.org\n corresponded to my host name.\n  Attempting to telnet into the address and port provided resulted in a failed\n  connection. Switching my hostname to \nlocahost\n allowed the main process\n  (and telnet) to connect and use the JVM process.", 
            "title": "Contributing"
        }, 
        {
            "location": "/about/contributing/#contributing-to-the-scala-debugger", 
            "text": "", 
            "title": "Contributing to the Scala Debugger"
        }, 
        {
            "location": "/about/contributing/#overview", 
            "text": "All contributions are welcome! As a reminder, project is licensed under the Apache 2.0 license .    Fork the repository .    Clone your forked version of the repository.  git clone git@github.com:your-username/scala-debugger.git    Add your code and associated tests. All code-related changes are expected\n   to either add new tests or update existing ones.    Validate that your changes pass the existing tests along with your own.  sbt test it:test    If relevant (new features, modifying existing features), please update\n   the documentation in  docs/ .    Push your fork and  submit a pull request .", 
            "title": "Overview"
        }, 
        {
            "location": "/about/contributing/#developer-notes", 
            "text": "Potential Gotchas    When moving from Mac OS X's IntelliJ to the IntelliJ of Linux Mint, the\n  tools.jar of OpenJDK/Oracle JDK was not picked up. I needed to manually open\n  up the SDK being used and add the tools.jar of \n   /usr/lib/jvm/java-7-openjdk-amd64/lib/  to the classpath. This allows me to\n  use the Sun-based  com.sun.jdi  package for a Java debugger interface rather\n  than C++.    When using the launching debugger, I noticed that it was creating an address\n  of senkbeil.org:RANDOMPORT.  senkbeil.org  corresponded to my host name.\n  Attempting to telnet into the address and port provided resulted in a failed\n  connection. Switching my hostname to  locahost  allowed the main process\n  (and telnet) to connect and use the JVM process.", 
            "title": "Developer Notes"
        }, 
        {
            "location": "/about/license/", 
            "text": "License\n\n\n\n\nScala Debugger API (Apache 2.0)\n\n\nApache License\n\n\nVersion 2.0, January 2004\n\n\nhttp://www.apache.org/licenses/\n\n\nTerms and Conditions for use, reproduction, and distribution\n\n\n1. Definitions\n\n\n\u201cLicense\u201d shall mean the terms and conditions for use, reproduction, and\ndistribution as defined by Sections 1 through 9 of this document.\n\n\n\u201cLicensor\u201d shall mean the copyright owner or entity authorized by the copyright\nowner that is granting the License.\n\n\n\u201cLegal Entity\u201d shall mean the union of the acting entity and all other entities\nthat control, are controlled by, or are under common control with that entity.\nFor the purposes of this definition, \u201ccontrol\u201d means \n(i)\n the power, direct or\nindirect, to cause the direction or management of such entity, whether by\ncontract or otherwise, or \n(ii)\n ownership of fifty percent (50%) or more of the\noutstanding shares, or \n(iii)\n beneficial ownership of such entity.\n\n\n\u201cYou\u201d (or \u201cYour\u201d) shall mean an individual or Legal Entity exercising\npermissions granted by this License.\n\n\n\u201cSource\u201d form shall mean the preferred form for making modifications, including\nbut not limited to software source code, documentation source, and configuration\nfiles.\n\n\n\u201cObject\u201d form shall mean any form resulting from mechanical transformation or\ntranslation of a Source form, including but not limited to compiled object code,\ngenerated documentation, and conversions to other media types.\n\n\n\u201cWork\u201d shall mean the work of authorship, whether in Source or Object form, made\navailable under the License, as indicated by a copyright notice that is included\nin or attached to the work (an example is provided in the Appendix below).\n\n\n\u201cDerivative Works\u201d shall mean any work, whether in Source or Object form, that\nis based on (or derived from) the Work and for which the editorial revisions,\nannotations, elaborations, or other modifications represent, as a whole, an\noriginal work of authorship. For the purposes of this License, Derivative Works\nshall not include works that remain separable from, or merely link (or bind by\nname) to the interfaces of, the Work and Derivative Works thereof.\n\n\n\u201cContribution\u201d shall mean any work of authorship, including the original version\nof the Work and any modifications or additions to that Work or Derivative Works\nthereof, that is intentionally submitted to Licensor for inclusion in the Work\nby the copyright owner or by an individual or Legal Entity authorized to submit\non behalf of the copyright owner. For the purposes of this definition,\n\u201csubmitted\u201d means any form of electronic, verbal, or written communication sent\nto the Licensor or its representatives, including but not limited to\ncommunication on electronic mailing lists, source code control systems, and\nissue tracking systems that are managed by, or on behalf of, the Licensor for\nthe purpose of discussing and improving the Work, but excluding communication\nthat is conspicuously marked or otherwise designated in writing by the copyright\nowner as \u201cNot a Contribution.\u201d\n\n\n\u201cContributor\u201d shall mean Licensor and any individual or Legal Entity on behalf\nof whom a Contribution has been received by Licensor and subsequently\nincorporated within the Work.\n\n\n2. Grant of Copyright License\n\n\nSubject to the terms and conditions of this License, each Contributor hereby\ngrants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free,\nirrevocable copyright license to reproduce, prepare Derivative Works of,\npublicly display, publicly perform, sublicense, and distribute the Work and such\nDerivative Works in Source or Object form.\n\n\n3. Grant of Patent License\n\n\nSubject to the terms and conditions of this License, each Contributor hereby\ngrants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free,\nirrevocable (except as stated in this section) patent license to make, have\nmade, use, offer to sell, sell, import, and otherwise transfer the Work, where\nsuch license applies only to those patent claims licensable by such Contributor\nthat are necessarily infringed by their Contribution(s) alone or by combination\nof their Contribution(s) with the Work to which such Contribution(s) was\nsubmitted. If You institute patent litigation against any entity (including a\ncross-claim or counterclaim in a lawsuit) alleging that the Work or a\nContribution incorporated within the Work constitutes direct or contributory\npatent infringement, then any patent licenses granted to You under this License\nfor that Work shall terminate as of the date such litigation is filed.\n\n\n4. Redistribution\n\n\nYou may reproduce and distribute copies of the Work or Derivative Works thereof\nin any medium, with or without modifications, and in Source or Object form,\nprovided that You meet the following conditions:\n\n\n\n\n(a)\n You must give any other recipients of the Work or Derivative Works a copy of\nthis License; and\n\n\n(b)\n You must cause any modified files to carry prominent notices stating that You\nchanged the files; and\n\n\n(c)\n You must retain, in the Source form of any Derivative Works that You distribute,\nall copyright, patent, trademark, and attribution notices from the Source form\nof the Work, excluding those notices that do not pertain to any part of the\nDerivative Works; and\n\n\n(d)\n If the Work includes a \u201cNOTICE\u201d text file as part of its distribution, then any\nDerivative Works that You distribute must include a readable copy of the\nattribution notices contained within such NOTICE file, excluding those notices\nthat do not pertain to any part of the Derivative Works, in at least one of the\nfollowing places: within a NOTICE text file distributed as part of the\nDerivative Works; within the Source form or documentation, if provided along\nwith the Derivative Works; or, within a display generated by the Derivative\nWorks, if and wherever such third-party notices normally appear. The contents of\nthe NOTICE file are for informational purposes only and do not modify the\nLicense. You may add Your own attribution notices within Derivative Works that\nYou distribute, alongside or as an addendum to the NOTICE text from the Work,\nprovided that such additional attribution notices cannot be construed as\nmodifying the License.\n\n\n\n\nYou may add Your own copyright statement to Your modifications and may provide\nadditional or different license terms and conditions for use, reproduction, or\ndistribution of Your modifications, or for any such Derivative Works as a whole,\nprovided Your use, reproduction, and distribution of the Work otherwise complies\nwith the conditions stated in this License.\n\n\n5. Submission of Contributions\n\n\nUnless You explicitly state otherwise, any Contribution intentionally submitted\nfor inclusion in the Work by You to the Licensor shall be under the terms and\nconditions of this License, without any additional terms or conditions.\nNotwithstanding the above, nothing herein shall supersede or modify the terms of\nany separate license agreement you may have executed with Licensor regarding\nsuch Contributions.\n\n\n6. Trademarks\n\n\nThis License does not grant permission to use the trade names, trademarks,\nservice marks, or product names of the Licensor, except as required for\nreasonable and customary use in describing the origin of the Work and\nreproducing the content of the NOTICE file.\n\n\n7. Disclaimer of Warranty\n\n\nUnless required by applicable law or agreed to in writing, Licensor provides the\nWork (and each Contributor provides its Contributions) on an \u201cAS IS\u201d BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied,\nincluding, without limitation, any warranties or conditions of TITLE,\nNON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A PARTICULAR PURPOSE. You are\nsolely responsible for determining the appropriateness of using or\nredistributing the Work and assume any risks associated with Your exercise of\npermissions under this License.\n\n\n8. Limitation of Liability\n\n\nIn no event and under no legal theory, whether in tort (including negligence),\ncontract, or otherwise, unless required by applicable law (such as deliberate\nand grossly negligent acts) or agreed to in writing, shall any Contributor be\nliable to You for damages, including any direct, indirect, special, incidental,\nor consequential damages of any character arising as a result of this License or\nout of the use or inability to use the Work (including but not limited to\ndamages for loss of goodwill, work stoppage, computer failure or malfunction, or\nany and all other commercial damages or losses), even if such Contributor has\nbeen advised of the possibility of such damages.\n\n\n9. Accepting Warranty or Additional Liability\n\n\nWhile redistributing the Work or Derivative Works thereof, You may choose to\noffer, and charge a fee for, acceptance of support, warranty, indemnity, or\nother liability obligations and/or rights consistent with this License. However,\nin accepting such obligations, You may act only on Your own behalf and on Your\nsole responsibility, not on behalf of any other Contributor, and only if You\nagree to indemnify, defend, and hold each Contributor harmless for any liability\nincurred by, or claims asserted against, such Contributor by reason of your\naccepting any such warranty or additional liability.\n\n\nEND OF TERMS AND CONDITIONS\n\n\nAPPENDIX: How to apply the Apache License to your work\n\n\nTo apply the Apache License to your work, attach the following boilerplate\nnotice, with the fields enclosed by brackets \n[]\n replaced with your own\nidentifying information. (Don't include the brackets!) The text should be\nenclosed in the appropriate comment syntax for the file format. We also\nrecommend that a file or class name and description of purpose be included on\nthe same \u201cprinted page\u201d as the copyright notice for easier identification within\nthird-party archives.\n\n\nCopyright [yyyy] [name of copyright owner]\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n  http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.", 
            "title": "License"
        }, 
        {
            "location": "/about/license/#license", 
            "text": "", 
            "title": "License"
        }, 
        {
            "location": "/about/license/#scala-debugger-api-apache-20", 
            "text": "Apache License  Version 2.0, January 2004  http://www.apache.org/licenses/  Terms and Conditions for use, reproduction, and distribution  1. Definitions  \u201cLicense\u201d shall mean the terms and conditions for use, reproduction, and\ndistribution as defined by Sections 1 through 9 of this document.  \u201cLicensor\u201d shall mean the copyright owner or entity authorized by the copyright\nowner that is granting the License.  \u201cLegal Entity\u201d shall mean the union of the acting entity and all other entities\nthat control, are controlled by, or are under common control with that entity.\nFor the purposes of this definition, \u201ccontrol\u201d means  (i)  the power, direct or\nindirect, to cause the direction or management of such entity, whether by\ncontract or otherwise, or  (ii)  ownership of fifty percent (50%) or more of the\noutstanding shares, or  (iii)  beneficial ownership of such entity.  \u201cYou\u201d (or \u201cYour\u201d) shall mean an individual or Legal Entity exercising\npermissions granted by this License.  \u201cSource\u201d form shall mean the preferred form for making modifications, including\nbut not limited to software source code, documentation source, and configuration\nfiles.  \u201cObject\u201d form shall mean any form resulting from mechanical transformation or\ntranslation of a Source form, including but not limited to compiled object code,\ngenerated documentation, and conversions to other media types.  \u201cWork\u201d shall mean the work of authorship, whether in Source or Object form, made\navailable under the License, as indicated by a copyright notice that is included\nin or attached to the work (an example is provided in the Appendix below).  \u201cDerivative Works\u201d shall mean any work, whether in Source or Object form, that\nis based on (or derived from) the Work and for which the editorial revisions,\nannotations, elaborations, or other modifications represent, as a whole, an\noriginal work of authorship. For the purposes of this License, Derivative Works\nshall not include works that remain separable from, or merely link (or bind by\nname) to the interfaces of, the Work and Derivative Works thereof.  \u201cContribution\u201d shall mean any work of authorship, including the original version\nof the Work and any modifications or additions to that Work or Derivative Works\nthereof, that is intentionally submitted to Licensor for inclusion in the Work\nby the copyright owner or by an individual or Legal Entity authorized to submit\non behalf of the copyright owner. For the purposes of this definition,\n\u201csubmitted\u201d means any form of electronic, verbal, or written communication sent\nto the Licensor or its representatives, including but not limited to\ncommunication on electronic mailing lists, source code control systems, and\nissue tracking systems that are managed by, or on behalf of, the Licensor for\nthe purpose of discussing and improving the Work, but excluding communication\nthat is conspicuously marked or otherwise designated in writing by the copyright\nowner as \u201cNot a Contribution.\u201d  \u201cContributor\u201d shall mean Licensor and any individual or Legal Entity on behalf\nof whom a Contribution has been received by Licensor and subsequently\nincorporated within the Work.  2. Grant of Copyright License  Subject to the terms and conditions of this License, each Contributor hereby\ngrants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free,\nirrevocable copyright license to reproduce, prepare Derivative Works of,\npublicly display, publicly perform, sublicense, and distribute the Work and such\nDerivative Works in Source or Object form.  3. Grant of Patent License  Subject to the terms and conditions of this License, each Contributor hereby\ngrants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free,\nirrevocable (except as stated in this section) patent license to make, have\nmade, use, offer to sell, sell, import, and otherwise transfer the Work, where\nsuch license applies only to those patent claims licensable by such Contributor\nthat are necessarily infringed by their Contribution(s) alone or by combination\nof their Contribution(s) with the Work to which such Contribution(s) was\nsubmitted. If You institute patent litigation against any entity (including a\ncross-claim or counterclaim in a lawsuit) alleging that the Work or a\nContribution incorporated within the Work constitutes direct or contributory\npatent infringement, then any patent licenses granted to You under this License\nfor that Work shall terminate as of the date such litigation is filed.  4. Redistribution  You may reproduce and distribute copies of the Work or Derivative Works thereof\nin any medium, with or without modifications, and in Source or Object form,\nprovided that You meet the following conditions:   (a)  You must give any other recipients of the Work or Derivative Works a copy of\nthis License; and  (b)  You must cause any modified files to carry prominent notices stating that You\nchanged the files; and  (c)  You must retain, in the Source form of any Derivative Works that You distribute,\nall copyright, patent, trademark, and attribution notices from the Source form\nof the Work, excluding those notices that do not pertain to any part of the\nDerivative Works; and  (d)  If the Work includes a \u201cNOTICE\u201d text file as part of its distribution, then any\nDerivative Works that You distribute must include a readable copy of the\nattribution notices contained within such NOTICE file, excluding those notices\nthat do not pertain to any part of the Derivative Works, in at least one of the\nfollowing places: within a NOTICE text file distributed as part of the\nDerivative Works; within the Source form or documentation, if provided along\nwith the Derivative Works; or, within a display generated by the Derivative\nWorks, if and wherever such third-party notices normally appear. The contents of\nthe NOTICE file are for informational purposes only and do not modify the\nLicense. You may add Your own attribution notices within Derivative Works that\nYou distribute, alongside or as an addendum to the NOTICE text from the Work,\nprovided that such additional attribution notices cannot be construed as\nmodifying the License.   You may add Your own copyright statement to Your modifications and may provide\nadditional or different license terms and conditions for use, reproduction, or\ndistribution of Your modifications, or for any such Derivative Works as a whole,\nprovided Your use, reproduction, and distribution of the Work otherwise complies\nwith the conditions stated in this License.  5. Submission of Contributions  Unless You explicitly state otherwise, any Contribution intentionally submitted\nfor inclusion in the Work by You to the Licensor shall be under the terms and\nconditions of this License, without any additional terms or conditions.\nNotwithstanding the above, nothing herein shall supersede or modify the terms of\nany separate license agreement you may have executed with Licensor regarding\nsuch Contributions.  6. Trademarks  This License does not grant permission to use the trade names, trademarks,\nservice marks, or product names of the Licensor, except as required for\nreasonable and customary use in describing the origin of the Work and\nreproducing the content of the NOTICE file.  7. Disclaimer of Warranty  Unless required by applicable law or agreed to in writing, Licensor provides the\nWork (and each Contributor provides its Contributions) on an \u201cAS IS\u201d BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied,\nincluding, without limitation, any warranties or conditions of TITLE,\nNON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A PARTICULAR PURPOSE. You are\nsolely responsible for determining the appropriateness of using or\nredistributing the Work and assume any risks associated with Your exercise of\npermissions under this License.  8. Limitation of Liability  In no event and under no legal theory, whether in tort (including negligence),\ncontract, or otherwise, unless required by applicable law (such as deliberate\nand grossly negligent acts) or agreed to in writing, shall any Contributor be\nliable to You for damages, including any direct, indirect, special, incidental,\nor consequential damages of any character arising as a result of this License or\nout of the use or inability to use the Work (including but not limited to\ndamages for loss of goodwill, work stoppage, computer failure or malfunction, or\nany and all other commercial damages or losses), even if such Contributor has\nbeen advised of the possibility of such damages.  9. Accepting Warranty or Additional Liability  While redistributing the Work or Derivative Works thereof, You may choose to\noffer, and charge a fee for, acceptance of support, warranty, indemnity, or\nother liability obligations and/or rights consistent with this License. However,\nin accepting such obligations, You may act only on Your own behalf and on Your\nsole responsibility, not on behalf of any other Contributor, and only if You\nagree to indemnify, defend, and hold each Contributor harmless for any liability\nincurred by, or claims asserted against, such Contributor by reason of your\naccepting any such warranty or additional liability.  END OF TERMS AND CONDITIONS  APPENDIX: How to apply the Apache License to your work  To apply the Apache License to your work, attach the following boilerplate\nnotice, with the fields enclosed by brackets  []  replaced with your own\nidentifying information. (Don't include the brackets!) The text should be\nenclosed in the appropriate comment syntax for the file format. We also\nrecommend that a file or class name and description of purpose be included on\nthe same \u201cprinted page\u201d as the copyright notice for easier identification within\nthird-party archives.  Copyright [yyyy] [name of copyright owner]\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n  http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.", 
            "title": "Scala Debugger API (Apache 2.0)"
        }
    ]
}